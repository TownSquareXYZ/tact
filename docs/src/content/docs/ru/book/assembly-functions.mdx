---
title: Функции сборки
description: Расширенные функции уровня модуля, которые позволяют писать инструкции TVM непосредственно в сборке Tact
---

import { Badge } from '@astrojs/starlight/components';

<Badge text="Доступно с Tact 1.5" variant="tip" size="medium"/><p/>

:::caution

  Это очень продвинутые функции, которые требуют опыта и бдительности как в определениях, так и в использовании. Логические ошибки в них крайне сложно обнаружить, сообщения об ошибках ужасны, а проверка типов в настоящее время не предоставляется Tact.

  Тем не менее, если вы знаете, что делаете, они могут предложить вам минимально возможное потребление газа, наилучшую производительность и максимальный контроль над выполнением [TVM][tvm]. Помните — с большой силой приходит большая ответственность.

:::

Функции сборки (или сокращенно функции asm) — это функции уровня модуля, которые позволяют вам создавать сборку Tact. В отличие от всех других функций, их тела состоят только из [инструкций TVM](#tvm) и некоторых других примитивов, и не используют никаких [операторов](/book/statements) или [выражений](/book/expressions) Tact.

```tact
// все функции сборки должны начинаться с ключевого слова "asm
// ↓
   asm fun answer(): Int { 42 INT }
//                         ------
//                         Обратите внимание, что тело содержит только
//                         инструкции TVM и некоторые примитивы,
//                         такие как числа или битовые строки, которые служат
//                         аргументами для инструкций
```

## Инструкции TVM {#tvm}

В Tact термин _инструкция TVM_ относится к команде, которая выполняется [TVM][tvm] во время его выполнения — [фаза вычислений](https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase). По возможности Tact попытается оптимизировать их использование для вас, но не будет определять новые или вводить посторонний синтаксис для их [предварительной обработки](https://docs.ton.org/v3/documentation/smart-contracts/fift/fift-and-tvm-assembly). Вместо этого рекомендуется объединить лучшее из инструкций Tact и TVM, как показано в примере [`onchainSha256(){:tact}`](#onchainsha256) в конце этой страницы.

Каждая [инструкция TVM][tvm-instructions], преобразованная в ее двоичное представление, представляет собой код операции (opcode), который должен быть выполнен [TVM][tvm], плюс некоторые необязательные аргументы к нему, записанные сразу после этого. Однако при записи инструкций в функциях `asm{:tact}` аргументы, если таковые имеются, записываются перед инструкцией и разделяются пробелами. Этот синтаксис [обратной польской нотации (RPN)](https://en.wikipedia.org/wiki/Reverse_Polish_notation) предназначен для демонстрации стековой природы [TVM][tvm].

Например, [`DROP2`](https://docs.ton.org/v3/documentation/tvm/instructions#5B) или его псевдоним [`2DROP`](https://docs.ton.org/v3/documentation/tvm/instructions#5B), которые удаляют (отбрасывают) два верхних значения из стека, имеют тот же префикс кода операции — `0x5B` или `1011011` в двоичном виде.

```tact
/// Помещает `a` и `b` в стек, а затем немедленно удаляет их из него
asm fun discardTwo(a: Int, b: Int) { DROP2 }
```

Аргументы [инструкций TVM][tvm-instructions] в Tact называются примитивами — они не манипулируют стеком сами по себе и не помещаются в него сами по себе. Попытка указать примитив без инструкции, которая немедленно его использует, приведет к ошибкам компиляции.

```tact
/// ОШИБКА КОМПИЛЯЦИИ!
/// 43 должны были быть аргументом некоторой последующей инструкции TVM
/// но не были найдены
asm fun bad(): Int { 43 }
```

Для некоторых инструкций результирующий код операции зависит от указанного примитива. Например, [`PUSHINT`](https://docs.ton.org/v3/documentation/tvm/instructions#7i) или его более короткий псевдоним [`INT`](https://docs.ton.org/v3/documentation/tvm/instructions#7i) имеют тот же код операции `0x7`, если указанный аргумент-число находится в диапазоне от $-5$ до $10$. Однако, если число больше этого, то код операции изменяется соответствующим образом: [`0x80`](https://docs.ton.org/v3/documentation/tvm/instructions#80xx) для аргументов в диапазоне от $-128$ до $127$, [`0x81`](https://docs.ton.org/v3/documentation/tvm/instructions#81xxxx) для аргументов в диапазоне от $-2^{15}$ до $2^{15}$ и т. д. Для вашего удобства все эти вариации кодов операций описаны с использованием одного и того же имени инструкции, в данном случае `PUSHINT`.

```tact
asm fun push42(): Int {
    // Следующие будут преобразованы в 0x80, за которым следует 0x2A
    // в их двоичном представлении для выполнения TVM
    42 PUSHINT
}
```

:::note[Useful Полезные ссылки:]

  [Список инструкций TVM в документации TON][tvm-instructions]

:::

## Соглашения о вызовах стека {#conventions}

Синтаксис для параметров и возвращаемых значений такой же, как и для других видов функций, но есть одно замечание — значения аргументов помещаются в стек до выполнения тела функции, а возвращаемый тип — это то, что извлекается из стека впоследствии.

### Параметры {#conventions-parameters}

Первый параметр помещается в стек первым, второй — вторым и т. д., так что первый параметр находится внизу стека, а последний — наверху.

```tact
asm extends fun storeCoins(self: Builder, value: Int): Builder {
    //                     ↑              ↑
    //                     |              Вставлен последним, находится на вершине стека
    //                     Вставлен первым, находится на дне стека

    // Сохраняет значение типа `Int как монеты` в Builder,
    // берет Builder из нижней части стека
    // и Int из верхней части стека,
    // создает новый Builder обратно
    STVARUINT16
}
```

Поскольку тела функций `asm{:tact}` не содержат операторов Tact, любые прямые ссылки на параметры в телах функций будут распознаны как инструкции [TVM][tvm], что может легко привести к очень неясным сообщениям об ошибках.

```tact
/// Просто возвращает значение `x`
asm fun identity(x: Int): Int { }

/// ОШИБКА КОМПИЛЯЦИИ!
/// `BOC` не распознается как параметр,
/// вместо этого интерпретируется как несуществующая инструкция TVM
asm fun bocchiThe(BOC: Cell): Cell { BOC }
```

Параметры произвольных типов [структуры][struct] распределяются по своим полям, рекурсивно уплощаются по мере помещения аргументов в стек. В частности, значение первого поля [структуры][struct] помещается первым, второе — вторым и т. д., так что значение первого поля оказывается внизу стека, а значение последнего — наверху. Если внутри этих [структур][struct] есть вложенные структуры, они уплощаются таким же образом.

:::note

  Такое поведение [структур][struct] является экспериментальным и может измениться в будущих выпусках Tact. В случае сомнений предпочтительнее указывать несколько параметров, чем одну [структуру][struct] со многими полями.

:::

```tact
// Структура с двумя полями типа Int
struct AB { a: Int; b: Int }

// Это вернет сумму двух полей в структуре `AB`
asm fun sum(two: AB): Int { ADD }

// Структура с двумя вложенными структурами `AB` в качестве полей
struct Nested { ab1: AB; ab2: AB }

// Это умножит суммы полей вложенных структур `AB`
asm fun mulOfSums(n: Nested): Int { ADD -ROT ADD MUL }

// Действие!
fun showcase() {
    sum(AB{ a: 27, b: 50 }); // 77
    //      ↑      ↑
    //      |      Помещен последним, находится на вершине стека
    //      Помещен первым, находится на дне стека

    mulOfSums(Nested{ ab1: AB{ a: 1, b: 2 }, ab2: AB{ a: 3, b: 4 } }); // 21
    //                         ↑     ↑                ↑     ↑
    //                         |     |                |     Помещен последним,
    //                         |     |                |     находится на вершине стека
    //                         |     |                Помещен предпоследним,
    //                         |     |                находится под вершиной стека
    //                         |     Помещен вторым,
    //                         |     находится прямо над дном стека
    //                         Помещен первым, находится на дне стека
}
```

### Возвраты {#conventions-returns}

Если присутствует, возвращаемый тип функции сборки пытается захватить соответствующие значения из результирующего стека после выполнения функции и возможных [расположений](#arrangements) стека. Однако, если отсутствует, функция сборки не берет никаких значений из стека.

Если присутствует, возвращаемый тип функции сборки пытается захватить соответствующие значения из результирующего стека после выполнения функции и любых [расположений](#arrangements). Однако, если возвращаемый тип отсутствует, функция сборки не берет никаких значений из стека.

```tact
// Помещает `x` в стек, увеличивает его там,
// но не захватывает результат, оставляя его в стеке
asm fun push(x: Int) { INC }
```

Указание [примитивного типа][p], например [`Int{:tact}`][int] или [`Cell{:tact}`][cell], заставит функцию сборки захватить верхнее значение из стека. Если тип времени выполнения полученного значения не соответствует указанному типу возврата, будет выдано исключение с [кодом выхода 7](/book/exit-codes#7): `Ошибка проверки типа`.

```tact
// ВЫЗЫВАЕТ ОШИБКУ ВО ВРЕМЯ ВЫПОЛНЕНИЯ ПРИ ВЫЗОВАХ!
// Помещает `x` в стек, ничего больше с ним не делает,
// затем пытается захватить его как Cell, вызывая код выхода 7: Ошибка проверки типа
asm fun push(x: Int): Cell { }
```

Как и в [параметрах](#conventions-parameters), произвольные возвращаемые типы [структуры][struct] распределяются по своим полям и рекурсивно сглаживаются в точно таком же порядке. Единственное отличие заключается в том, что теперь они захватывают значения из стека и делают это справа налево — последнее поле [структуры][struct] захватывает самое верхнее значение из стека, предпоследнее захватывает второе сверху и т. д., так что последнее поле содержит значение с вершины стека, а первое поле содержит значение с низа.

```tact
// Структура с двумя полями типа Int
struct MinMax { minVal: Int; maxVal: Int }

// Помещает `a` и `b` в стек,
// затем захватывает два значения обратно через структуру `MinMax`
asm fun minmax(a: Int, b: Int): MinMax { MINMAX }
```

Если тип времени выполнения некоторого захваченного значения не соответствует указанному типу поля [структуры][struct] или вложенной [структуры][struct], если таковая имеется, будет выдано исключение с [кодом выхода 7](/book/exit-codes#7): `Ошибка проверки типа`. Более того, попытки захватить больше значений, чем было в стеке, выдают исключение с [кодом выхода 2](/book/exit-codes#2): `Переполнение стека`.

```tact
// Структура со слишком большим количеством полей для обработки начальным стеком
struct Handler { f1: Int; f2: Int; f3: Int; f4: Int; f5: Int; f6: Int; f7: Int }

// ВЫЗЫВАЕТ ОШИБКУ ВО ВРЕМЕНИ ВЫПОЛНЕНИЯ ПРИ ВЫЗОВАХ!
// Пытается захватить 7 значений из стека и сопоставить их с полями `Handler`,
// но после инициализации TVM в начальном стеке просто не так много значений,
// что приводит к выдаче кода выхода 2: переполнение стека
asm fun overHandler(): Handler { }
```

В качестве параметров и возвращаемых значений функций сборки [структур][struct] могут иметь не более $16$ полей. Каждое из этих полей, в свою очередь, может быть объявлено как другая [структура][struct], где каждая из этих вложенных структур также может иметь не более $16$ полей. Этот процесс можно повторять до тех пор, пока не будет получено в общей сложности $256$ полей [примитивных типов][p] из-за [ограничений функции сборки](#limitations). Это ограничение также распространяется на список параметров функций сборки — можно объявить не более $16$ параметров.

```tact
// Семнадцать полей
struct S17 { f1:Int; f2:Int; f3:Int; f4:Int; f5:Int; f6:Int; f7:Int; f8:Int; f9:Int; f10:Int; f11:Int; f12:Int; f13:Int; f14:Int; f15:Int; f16:Int; f17:Int }

// ОШИБКА КОМПИЛЯЦИИ!
asm fun chuckles(imInDanger: S17) { }
```

## Регистры стека {#stack-registers}

Так называемые _регистры стека_ — это способ ссылки на значения наверху стека. Всего существует $256$ регистров стека, т. е. значений, хранящихся в стеке в любой момент времени. Вы можете указать любой из них, используя любой из `s0`, `s1`, ..., `s255`, но только если определенная инструкция [TVM][tvm] ожидает его в качестве аргумента. В противном случае их концепция предназначена для краткого описания эффектов конкретной инструкции [TVM][tvm] в тексте или комментариях к коду, а не в самом коде.

Регистр `s0` — это значение наверху стека, регистр `s1` — это значение сразу после него и так далее, пока мы не достигнем дна стека, представленного `s255`, т. е. $256$-го регистра стека. Когда значение `x` помещается в стек, оно становится новым `s0`. В то же время старый `s0` становится новым `s1`, старый `s1` — новым `s2` и так далее.

```tact
asm fun takeSecond(a: Int, b: Int): Int {
    //             ↑       ↑
    //             |       Вставлен последним, находится на вершине стека
    //             Вставлен первым, находится вторым сверху стека

    // Теперь давайте поменяем местами s0 (вершина стека) с s1 (вторая сверху)
    // До │ После
    // ───────┼───────
    // s0 = b │ s0 = a
    // s1 = a │ s1 = b
    SWAP

    // Затем давайте сбросим значение с вершины стека

    // До │ После
    // ───────┼───────
    // s0 = a │ s0 = b
    // s1 = b │ s1 теперь либо имеет какое-то значение глубже, либо просто пустое
    DROP

    // В конце у нас есть только одно значение в стеке, которое равно b
    // Таким образом, оно захватывается нашим возвращаемым типом `Int`
}

fun showcase() {
    takeSecond(5, 10); // 10, т. е. b
}
```

:::caution

  Попытки доступа к пустому регистру стека, т. е. к регистру без значения на момент доступа, вызывают исключение с [кодом выхода 2](/book/exit-codes#2): `Незаполнение стека`.

  Подробнее об ограничениях стека: [Ограничения](#limitations).

:::

## Компоновки {#arrangements}

Часто бывает полезно изменить порядок аргументов, помещаемых в стек, или порядок возвращаемых значений, не ссылаясь на регистры стека в теле. Это можно сделать с помощью `asm{:tact}` компоновок — с ними поток вычисления функции сборки можно представить в виде следующих $5$ шагов:

1. Функция принимает аргументы в порядке, указанном параметрами.
2. Если присутствует компоновка аргументов, аргументы переупорядочиваются перед помещением в стек.
3. Выполняется тело функции, состоящее из [инструкций TVM][tvm-instructions] и примитивов.
4. Если присутствует компоновка результата, результирующие значения переупорядочиваются в стеке.
5. Результирующие значения захватываются (частично или полностью) возвращаемым типом функции.

Компоновка аргументов имеет синтаксис `asm(arg2 arg1)`, где `arg1` и `arg2` — некоторые аргументы функции в порядке, в котором мы хотим поместить их в стек: `arg1` будет помещен первым и попадет в низ стека, в то время как `arg2` будет помещен последним и попадет в верх стека. Компоновки не ограничены двумя аргументами и работают со всеми параметрами функции. Если есть какие-либо параметры произвольных типов [структуры][struct], их компоновка выполняется до их выравнивания.

```tact
// Изменение порядка аргументов для соответствия сигнатуре STDICT:
// `c` будет помещен первым и попадет в низ стека,
// в то время как `self` будет помещен последним и попадет в вершину стека
asm(c self) extends fun asmStoreDict(self: Builder, c: Cell?): Builder { STDICT }
```

Компоновка возврата имеет синтаксис `asm(-> 1 0)`, где $1$ и $0$ являются переупорядочением слева направо [регистров стека](#stack-registers) `s1` и `s0` соответственно: содержимое `s1` будет наверху стека, за ним следует содержимое `s0`. Компоновки не ограничены двумя возвращаемыми значениями и работают с записанными значениями. Если в качестве возвращаемого типа указана произвольная [структура][struct], то схема выполняется относительно их полей, отображая значения в стеке в рекурсивно сглаженной [структуре][struct].

```tact
// Изменение порядка возвращаемых значений инструкции LDVARUINT16,
// поскольку изначально она поместила бы измененный срез на вершину стека
asm(-> 1 0) extends fun asmLoadCoins(self: Slice): SliceInt { LDVARUINT16 }
//     ↑ ↑
//     | Значение регистра стека 0,
//     | которое является самым верхним значением в стеке
//     Значение стекового регистра 1,
//     которое является вторым сверху значением в стеке
// И возвращаемый тип `SliceInt`,
// который является следующей структурой:
struct SliceInt { s: Slice; val: Int }
```

И аргумент, и возвращаемое расположение можно объединить вместе и записать следующим образом: `asm(arg2 arg1 -> 1 0)`.

```tact
// Изменение порядка возвращаемых значений по сравнению со стеком
// и переключение порядка аргументов, а также
asm(s len -> 1 0) fun asmLoadInt(len: Int, s: Slice): SliceInt { LDIX }
//           ↑ ↑
//           | Значение стекового регистра 0,
//           | которое является самым верхним значением в стеке
//           Значение регистра стека 1,
//           которое является вторым сверху значением в стеке
// И возвращаемый тип `SliceInt`,
// который является следующей структурой:
struct SliceInt { s: Slice; val: Int }
```

Используя все эти переупорядоченные функции вместе, мы получаем:

```tact
asm(c self) extends fun asmStoreDict(self: Builder, c: Cell?): Builder { STDICT }
asm(-> 1 0) extends fun asmLoadCoins(self: Slice): SliceInt { LDVARUINT16 }
asm(s len -> 1 0) fun asmLoadInt(len: Int, s: Slice): SliceInt { LDIX }
struct SliceInt { s: Slice; val: Int }

fun showcase() {
    let b = beginCell()
        .storeCoins(42)
        .storeInt(27, 10)
        .asmStoreDict(emptyMap());

    let s = b.asSlice();
    let si: SliceInt = s.asmLoadCoins(); // Остаток среза и 42
    s = si.s; // Назначение измененного среза
    let coins = si.val; // 42
    let si2: SliceInt = asmLoadInt(10, s); // Остаток среза и 27
}
```

Обратите внимание, что компоновки не сбрасывают и не отбрасывают никакие значения — они только манипулируют порядком аргументов и возвращают значения, как они объявлены. Это означает, например, что компоновка не может получить доступ к значениям из стека, которые не захвачены возвращаемым типом функции сборки.

Тем не менее, есть [предостережение к атрибуту `mutates{:tact}` и компоновкам `asm`](#caveats-mutates).

## Ограничения {#limitations}

Попытки сбросить количество значений стека ниже $0$ вызывают исключение с [кодом выхода 2](/book/exit-codes#2): `Неполный стек`.

```tact
asm fun drop() { DROP }

fun exitCode2() {
    // Удаляет гораздо больше элементов из стека
    // чем было раньше, вызывая неполноту
    repeat (100) { drop() }
}
```

Сам стек [TVM][tvm] не имеет **никаких** ограничений на общее количество значений, поэтому теоретически вы можете помещать туда новые значения, пока не исчерпаете запас. Однако различные [продолжения](https://docs.ton.org/v3/documentation/tvm/tvm-overview#tvm-is-a-stack-machine) могут иметь максимальное количество значений, определенное для их внутренних стеков, превышение которого вызовет исключение с [кодом выхода 3](/book/exit-codes#3): `стек переполнен`.

```tact
asm fun stackOverflow() {
    x{} SLICE        // s
    BLESS            // c
    0 SETNUMARGS     // c'
    2 PUSHINT        // c' 2
    SWAP             // 2 c'
    1 -1 SETCONTARGS // ← это сработает
}

fun exitCode3() {
    // Переполняет внутренний стек продолжения
    stackOverflow();
}
```

Хотя всего $256$ [регистров стека](#stack-registers), сам стек может содержать более $256$ значений. Более глубокие значения не будут немедленно доступны никаким [инструкциям TVM][tvm-instructions], но они все равно будут в стеке.

## Предостережения {#caveats}

### Чувствительность к регистру {#caveats-case}{#caveats-case}

[Инструкции TVM][tvm-instructions] чувствительны к регистру и всегда пишутся заглавными буквами.

```tact
/// ОШИБКА!
asm fun bad1(): Cell { mycode }

/// ОШИБКА!
asm fun bad2(): Cell { MyCoDe }

/// 👍
asm fun good(): Cell { MYCODE }
```

### Двойные кавычки не нужны {#caveats-quotes}

Необязательно заключать [инструкции TVM][tvm-instructions] в двойные кавычки. Напротив, они затем интерпретируются как строки, что, вероятно, _не_ то, что вам нужно:

```tact
// Помещает строку "MYCODE" в стек времени компиляции,
// где она отбрасывается еще до начала фазы вычислений
asm fun wrongMyCode() { "MYCODE" }

// Вызывает инструкцию TVM MYCODE во время фазы вычислений,
// которая возвращает код контракта как ячейку
asm fun myCode(): Cell { MYCODE }
```

### `mutates` содержит дополнительное значение {#caveats-mutates}

Указание атрибута [`mutates{:tact}`](/book/functions#mutation-functions), т. е. определение функции мутации, приводит к тому, что функция сборки использует на одно значение больше в стеке, чем заявленные возвращаемые значения. Рассмотрим следующий пример:

```tact
asm(-> 1 0) extends mutates fun loadRef(self: Slice): Cell { LDREF }
```

Там инструкция `LDREF` создает две записи стека: [`Cell{:tact}`][cell] и измененную [`Slice{:tact}`][slice] в указанном порядке, при этом [`Slice{:tact}`][slice] помещается наверх стека. Затем расположение `-> 1 0{:tact}` инвертирует эти значения, помещая [`Cell{:tact}`][cell] наверх стека.

Наконец, атрибут [`mutates{:tact}`](/book/functions#mutation-functions) заставляет функцию использовать самое глубокое значение в стеке, т. е. [`Slice{:tact}`][slice], и ​​присваивать его `self{:tact}`, возвращая при этом значение [`Cell{:tact}`][cell] вызывающей стороне.

В целом, атрибут [`mutates{:tact}`](/book/functions#mutation-functions) может быть полезен в некоторых случаях, но вы должны быть бдительны при его использовании с функциями сборки.

:::caution

  Если тип самого глубокого значения в стеке не будет соответствовать типу `self{:tact}`, то будет выдано исключение с [кодом выхода 7](/book/exit-codes#7): `Ошибка проверки типа`.

:::

### Не полагайтесь на начальные значения стека {#caveats-initial}

[TVM][tvm] помещает несколько значений в свой стек при инициализации, и эти значения основаны на [событии, вызвавшем транзакцию][tvm-init]. В других языках вам, возможно, пришлось бы полагаться на их порядок и типы, в то время как в Tact разбор выполняется за вас. Таким образом, в Tact эти начальные значения стека отличаются от [того, что описано в документации TON][tvm-init].

:::caution

  Начальные элементы, помещенные в стек во время [инициализации TVM][tvm-init] и измененные Tact **должны** оставаться в стеке до конца тела функции и быть единственными присутствующими там значениями. Если этого не происходит, выдается исключение с [кодом выхода 7](/book/exit-codes#7): `Ошибка проверки типа`.

:::

Поэтому для доступа к таким данным, как количество [nanoToncoin](/book/integers#nanotoncoin) в сообщении или [`Address{:tact}`][p] отправителя, настоятельно рекомендуется вызывать функции [`context(){:tact}`](/ref/core-common#context) или [`sender(){:tact}`](/ref/core-common#sender) вместо того, чтобы пытаться искать их.

## Отладка {#debugging}

Количество значений, которые стек имеет в любой момент времени, называется _глубиной_, и она доступна через инструкцию [`DEPTH`](https://docs.ton.org/v3/documentation/tvm/instructions#68). Она довольно удобна для просмотра количества значений до и после вызова отлаживаемых функций сборки и может использоваться в логике asm.

```tact
asm fun depth(): Int { DEPTH }
```

Чтобы увидеть как глубину стека, так и значения в нем, в основной библиотеке Tact есть функция: [`dumpStack(){:tact}`](/ref/core-debug#dumpstack). Она отлично подходит для отслеживания стека во время отладки, хотя и требует больших вычислительных затрат и только выводит значения, а не возвращает их, поэтому используйте его с осторожностью и только при тестировании.

Подробнее об отладке контрактов Tact читайте на специальной странице: [Отладка](/book/debug).

## Атрибуты {#attributes}

Могут быть указаны следующие атрибуты:

- `inline{:tact}` — ничего не делает, так как функции сборки всегда встроены.
- [`extends{:tact}`](/book/functions#extension-function) — делает [функцию расширения](/book/functions#extension-function).
- [`mutates{:tact}`](/book/functions#mutation-functions) (вместе с [`extends{:tact}`](/book/functions#extension-function)) — делает [расширенную функцию мутации](/book/functions#mutation-functions).

Эти атрибуты _нельзя_ указывать:

- `abstract{:tact}` — функции сборки должны иметь определенное тело.
- `virtual{:tact}` и `override{:tact}` — функции сборки не могут быть определены в контракте или типаже.
- [`get{:tact}`](/book/functions#getter-functions) — функции сборки не могут быть [геттерами](/book/functions#getter-functions).

```tact
/// `Builder.storeCoins()` функция расширения
asm extends fun storeCoins(self: Builder, value: Int): Builder {
    STVARUINT16
}

/// `Slice.skipBits()` функция расширения мутации
asm extends mutates fun skipBits(self: Slice, l: Int) {
    SDSKIPFIRST
}
```

## Интересные примеры {#examples}

На странице [TVM инструкции][tvm-instructions] вы могли заметить, что "сигнатуры" инструкций записаны в специальной форме, называемой _stack notation_, которая описывает состояние стека до и после выполнения данной инструкции.

Например, `x y - z` описывает инструкцию, которая извлекает два значения `x` и `y` из стека, с `y` наверху стека и `x` вторым сверху, а затем помещает результат `z` в стек. Обратите внимание, что другие значения, расположенные глубже в стеке, не доступны.

Эта нотация опускает информацию о типе и только неявно описывает состояние регистров стека, поэтому для следующих примеров мы будем использовать другую, объединяющую понятия параметров и возвращаемых значений с нотацией стека следующим образом:

```tact
//   Типы параметров
//   |      |       и показаны типы возвращаемых значений
//   ↓      ↓       ↓
// x:Int, y:Int → z:Int — все разделены запятыми
// —————————————————————
// s1     s0    → s0
// ↑      ↑       ↑
// Также показаны регистры стека,
// что помогает визуально сопоставить их с параметрами и возвращаемыми значениями
```

Когда задействованы литералы, они будут показаны как есть. Кроме того, когда значения в стеке не представляют параметры или поля [структуры][struct] возвращаемого типа, указывается только их тип.

### keccak256

```tact
// Вычисляет и возвращает хэш Keccak-256 как 256-битный беззнаковый `Int`
// из переданного `Slice` `s`. Использует реализацию, совместимую с Ethereum.
asm fun keccak256(s: Slice): Int {
    // s:Slice → s:Slice, 1
    // —————————————————————
    // s0      → s1       s0
    ONE

    // s:Slice, 1  → h:Int
    // ———————————————————
    // s1       s0 → s0
    HASHEXT_KECCAK256
}
```

[`HASHEXT_SHA256`](https://docs.ton.org/v3/documentation/tvm/instructions#F90400) и Инструкции [`HASHEXT_BLAKE2B`](https://docs.ton.org/v3/documentation/tvm/instructions#F90402) можно использовать аналогичным образом, в отношении разного количества возвращаемых значений. Кроме того, все они также могут работать со значениями типа [`Builder{:tact}`][builder].

Однако инструкции [`HASHEXT_KECCAK512`](https://docs.ton.org/v3/documentation/tvm/instructions#F90404) и [`HASHEXT_SHA512`](https://docs.ton.org/v3/documentation/tvm/instructions#F90401) помещают в стек кортеж из двух целых чисел вместо того, чтобы помещать туда два отдельных целых числа. Из-за этого вам также нужно будет добавить инструкцию `UNPAIR` сразу после них.

```tact
// Вычисляет и возвращает хэш Keccak-512 в двух 256-битных беззнаковых `Int`
// значениях из переданного `Slice` `s`. Использует реализацию, совместимую с Ethereum.
asm fun keccak256(s: Slice): Hash512 {
    // s:Slice → s:Slice, 1
    // —————————————————————
    // s0      → s1       s0
    ONE

    // s:Slice, 1  → Tuple(h1:Int, h2:Int)
    // ———————————————————————————————————
    // s1       s0 → s0
    HASHEXT_KECCAK512

    // Tuple(h1:Int, h2:Int) → h1:Int, h2:Int
    // —————————————————————————————————————
    // s0                    → s1      s2
    UNPAIR // можно было бы использовать UNTUPLE и в более общем случае
}

// Вспомогательная структура
struct Hash512 { h1: Int; h2: Int }
```

:::note[Useful Полезные ссылки:]

  [`HASHEXT_KECCAK256`](https://docs.ton.org/v3/documentation/tvm/instructions#F90403)\
  [`HASHEXT_KECCAK512`](https://docs.ton.org/v3/documentation/tvm/instructions#F90404)\
  [Ссылка на реализацию Keccak-256](https://keccak.team/index.html)

:::

### isUint8

Сопоставление с одной инструкцией само по себе неэффективно, если значения, которые они помещают в стек, могут различаться в зависимости от некоторых условий. Это связано с тем, что нельзя напрямую сопоставить их с типами Tact и часто требуется выполнить некоторые дополнительные манипуляции со стеком до или после их выполнения.

Поскольку это часто касается "тихих" версий инструкций, рекомендуется отдавать предпочтение их нетихим альтернативам. Обычно нетихие версии выдают исключения и последовательны в своих возвращаемых значениях, в то время как тихие версии помещают $-1$ или другие значения в стек, тем самым изменяя количество или тип своих результирующих значений.

В более простых случаях, таких как этот пример, удобно выполнять все манипуляции со стеком в рамках одной функции.

```tact
// Проверяет, находится ли заданный `Int` `val` в
// включительном диапазоне от 0 до 255
asm fun isUint8(val: Int): Bool {
    // val:Int → val:Int или NaN
    // ————————————————————————
    // s0      → s0
    8 QUFITS

    // val:Int или NaN → Bool
    // —————————————————————
    // s0             → s0
    ISNAN

    // Поскольку ISNAN возвращает true, когда `val` NaN,
    // т. е. когда `val` не вписывается в диапазон uint8,
    // нам нужно его перевернуть

    // Bool → Bool
    // ———————————
    // s0   → s0
    NOT // можно было бы использовать 0 EQINT тоже
}

fun showcase() {
    isUint8(55);            // true
    isUint8(-55);           // false
    isUint8(pow(2, 8));     // false
    isUint8(pow(2, 8) - 1); // true
}
```

### ecrecover

В этом примере показан один из возможных способов работы с частично записанными результатами из стека, с последующим получением пропущенных результатов.

```tact
// Восстанавливает открытый ключ из подписи, как это делается в Bitcoin или Ethereum
//
// Берет 256-битное беззнаковое целое число `hash` и 65-байтовую подпись:
// * 8-битное беззнаковое целое число `v`
// * и 256-битные беззнаковые целые числа `r` и `s`
//
// Возвращает `null` в случае неудачи или структуру `EcrecoverKey` в случае успеха
fun ecrecover(hash: Int, v: Int, r: Int, s: Int): EcrecoverKey? {
    let successful = _ecrecoverExecute(hash, v, r, s);
    if (successful) {
        return _ecrecoverSuccess();
    } else {
        return null;
    }
}

// 65-байтовый открытый ключ, возвращаемый `ecrecover()` в случае успеха,
// который состоит из 8-битного беззнакового целого числа `h`
// и 256-битных беззнаковых целых чисел `x1` и `x2`
struct EcrecoverKey {
    h: Int as uint8;
    x1: Int as uint256;
    x2: Int as uint256;
}

// Базовая функция сборки, которая выполняет работу
// и захватывает только самое верхнее значение из стека
//
// Поскольку инструкция `ECRECOVER` помещает 0 на вершину стека
// в случае неудачи и -1 в случае успеха,
// это прекрасно отображается на тип Bool
asm fun _ecrecoverExecute(hash: Int, v: Int, r: Int, s: Int): Bool { ECRECOVER }

// Просто захватывает значения из стека
// если вызов `ecrecoverExecute()` был успешным
asm fun _ecrecoverSuccess(): EcrecoverKey { }
```

### onchainSha256

Этот пример расширяет [`ecrecover(){:tact}`](#ecrecover) и добавляет более сложное управление стеком и взаимодействие с операторами Tact, такими как циклы.

```tact
// Вычисляет и возвращает хэш SHA-256
// как 256-битное беззнаковое `Int` заданных `data`.
// В отличие от функции `sha256()` из библиотеки Core,
// эта работает исключительно в цепочке (во время выполнения), полностью хешируя строки,
// тогда как `sha256()` надежно работает только с их первыми 1023 битами данных
fun onchainSha256(data: String): Int {
    _onchainShaPush(data);
    while (_onchainShaShouldProceed()) {
        _onchainShaOperate();
    }
    return _onchainShaHashExt();
}

// Вспомогательные функции сборки,
// каждая из которых манипулирует стеком по-своему
// в разных частях функции `onchainSha256()`
asm fun _onchainShaPush(data: String) { ONE }
asm fun _onchainShaShouldProceed(): Bool { OVER SREFS 0 NEQINT }
asm fun _onchainShaOperate() { OVER LDREF s0 POP CTOS s0 s1 XCHG INC }
asm fun _onchainShaHashExt(): Int { HASHEXT_SHA256 }
```

:::note[Useful Полезные ссылки:]

  [Обзор TVM в документации TON][tvm]\
[Список инструкций TVM в документации TON][tvm-instructions]

:::

[п]: /book/types#primitive-types
[структурировать]: /book/structs-and-messages#structs
[инт]: /book/integers
[ячейка]: /book/cells#cells
[конструктор]: /book/cells#builders
[кусочек]: /book/cells#slices
[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[tvm-instructions]: https://docs.ton.org/v3/documentation/tvm/instructions
[tvm-init]: https://docs.ton.org/v3/documentation/tvm/tvm-initialization#stack
