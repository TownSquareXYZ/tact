---
title: Контракты
description: Контракты в Tact похожи на классы в популярных объектно-ориентированных языках, за исключением того, что их экземпляры развернуты в блокчейне и их нельзя передавать, как структуры и сообщения
---

Контракты в Tact похожи на классы в популярных объектно-ориентированных языках, за исключением того, что их экземпляры развернуты в блокчейне и их нельзя передавать, как [структуры и сообщения](/book/structs-and-messages).

## Ссылки на себя {#self}

Контракты и [признаки][trait] имеют встроенный [идентификатор](/book/expressions#identifiers) `self{:tact}`, который используется для ссылки на их поля (постоянные состояния [переменных](#variables) и [константы](#variables)) и методы ([внутренние функции](#internal-functions)):

```tact
contract Example {
    // постоянные переменные состояния
    foo: Int;

    init() {
        self.foo = 42; // <- обращение к переменной foo через self.
    }
}
```

## Структура

Каждый контракт может содержать:

- [Унаследованные черты](#traits)
- [Поддерживаемые интерфейсы](#interfaces)
- [Постоянные переменные состояния](#variables)
- [Функция конструктора `init(){:tact}`](#init-function)
- [Контрактные константы](#constants)
- [Функции-получатели](#getter-functions)
- [Функции приемника](#receiver-functions)
- [Внутренние функции](#internal-functions)

### Унаследованные признаки, `с{:tact}` {#traits}

Контракты могут наследовать все объявления и определения из [признаков][trait] и переопределять некоторые из их поведений по умолчанию. В дополнение к этому, каждый контракт и признак неявно наследуют специальный [`BaseTrait{:tact}` признак](/ref/core-base).

Чтобы наследовать [признак][trait], укажите его имя после ключевого слова `with{:tact}` в объявлении контракта. Чтобы унаследовать несколько признаков одновременно, укажите их названия в списке, разделенном запятыми, с необязательной запятой в конце.

```tact /with/
trait InheritMe {}
trait InheritMeToo {}

// Контракт, наследующий один признак
contract Single с InheritMe {}

// Контракт, наследующий несколько признаков
contract Plural с
    InheritMe,
    InheritMeToo, // допускается запятая в конце
{}
```

Поскольку [признаки][трейт] не могут иметь функцию [`init(){:tact}`](#init-function), контракт, наследующий признак с любыми объявленными [переменными постоянного состояния](#variables), должен инициализировать их, предоставив собственную функцию [`init(){:tact}`](#init-function).

```tact
trait Supe { omelander: Bool }

contract Vot with Supe {
    init() {
        self.omelander = true;
    }
}
```

Если они объявлены или определены в признаке, внутренние функции и константы могут быть помечены как [виртуальные или абстрактные](/book/functions#virtual-and-abstract-functions) и переопределены в контрактах, наследующих от признака.

### Поддерживаемые интерфейсы, `@interface(…)` {#interfaces}

Трудно понять, что делает контракт и какие у него [приёмники](#receiver-functions) и [получатели](#getter-functions), не заглядывая в его исходный код. Иногда исходный код недоступен, и все, что остается, - это попытаться разобрать контракт и провести его интроспекцию таким образом, что является очень запутанным и подверженным ошибкам подходом с уменьшающейся отдачей и отсутствием реальной воспроизводимости.

Для решения этой проблемы был создан [OTP-001: Поддерживаемые интерфейсы](/ref/evolution/otp-001). В соответствии с ним контракты Tact [могут сообщать](/book/config#options-interfacesgetter) список поддерживаемых интерфейсов как возвращаемое значение специального `supported_interfaces` [получателя](#getter-functions). Этот получатель доступен off-chain с помощью любого проводника блокчейна TON — нужно просто указать `supported_interfaces` как метод для выполнения и получить в ответ список шестнадцатеричных значений.

Эти шестнадцатеричные значения усекаются до первых 128 бит [SHA-256](https://en.wikipedia.org/wiki/SHA-2#Hash_standard) хэшей исходных значений [`String{:tact}`][p] поддерживаемых интерфейсов. Первое значение в этом списке **должно** быть равно $\mathrm{0x5cec3d5d2cae7b1e84ec39d64a851b66}$ в [шестнадцатеричной нотации](/book/integers#hexadecimal), что является первой половиной хэша SHA-256 для `"org.ton.introspection.v0"{:tact}`. Если первое значение неверно, вам следует прекратить попытки интроспекции контракта, поскольку он не соответствует предложению [поддерживаемых интерфейсов](/ref/evolution/otp-001).

Чтобы объявить поддержку определенного интерфейса, добавьте один или несколько атрибутов `@interface("…"){:tact}` прямо перед объявлениями контракта и [признака][trait]:

```tact
@interface("His name is")
@interface("John")
contract SeeNah with Misc {
    // ...
}

@interface("name_of_your_org - miscellaneous")
trait Misc {
    // ...
}
```

Tact имеет небольшой набор интерфейсов, предоставляемых при определенных условиях:

- `"org.ton.abi.ipfs.v0"{:tact}`, в соответствии с [OTP-003: Самостоятельный отчет ABI](/ref/evolution/otp-003) — подпишитесь через свойство конфигурации [`ipfsAbiGetter`](/book/config#options-ipfsabigetter)
- `"org.ton.deploy.lazy.v0"{:tact}`, в соответствии с [OTP-005: Контракты, адресуемые аргументами](/ref/evolution/otp-005)
- `"org.ton.debug.v0"{:tact}`, но только если [режим отладки](/book/debug#debug-mode) включен
- `org.ton.chain.any.v0"{:tact}`, если включена поддержка [мастерчейна](/book/masterchain), и `org.ton.chain.workchain.v0`{:tact}\` в противном случае

Некоторые [признаки][trait] в [стандартных библиотеках](/ref/standard-libraries) также определяют свои интерфейсы:

- [`Ownable{:tact}`](/ref/stdlib-ownable#ownable) признак указывает на `"org.ton.ownable"{:tact}`
- [`OwnableTransferable{:tact}`](/ref/stdlib-ownable#ownabletransferable) признак указывает на `"org.ton.ownable.transferable.v2"{:tact}`
- [`Stoppable{:tact}`](/ref/stdlib-stoppable#stoppable) признак указывает на `"org.ton.stoppable"{:tact}`
- [`Resumable{:tact}`](/ref/stdlib-stoppable#resumable) черта указывает на `"org.ton.resumable"{:tact}`

Чтобы включить генерацию и использование `supported_interfaces` [получателя](#getter-functions) `@interface(){:tact}` и использовать атрибут в ваших контрактах Tact, измените файл [`tact.config.json`](/book/config) в корне вашего проекта (или создайте его, если он еще не существует) и [установите свойство `interfacesGetter` в `true{:json}`](/book/config#options-interfacesgetter).

Если вы работаете над проектом на основе [Blueprint][bp], вы можете включить `supported_interfaces` в конфигурациях компиляции ваших контрактов, которые находятся в каталоге с именем `wrappers/`:

```typescript title="wrappers/YourContractName.compile.ts" {7}
import { CompilerConfig } from '@ton/blueprint';

export const compile: CompilerConfig = {
  lang: 'tact',
  target: 'contracts/your_contract_name.tact',
  options: {
    interfacesGetter: true, // ← вот эта вещь!
  }
};
```

Кроме того, [`tact.config.json`](/book/config) по-прежнему может использоваться в проектах [Blueprint][bp]. В таких случаях значения, указанные в [`tact.config.json`](/book/config), действуют как значения по умолчанию, если они не изменены в `wrappers/`.

:::note

  Если у вас параметр `separateCompilables` установлен на `true{:typescript}` в [`blueprint.config.ts`][bp-config], то файлы `.compile.ts` будут находиться в каталоге `compilables/`, а **не** в `wrappers/`.

:::

:::caution

  Помните, что добавление интерфейса не гарантирует, что контракт действительно реализует какую-либо конкретную функциональность или реализует ее каким-либо определенным образом. Это просто проверяемый промис off-chain, что контракт _может_ содержать определенный код. Вы можете доверять таким заявлениям, но проверять их.

  Кроме того, нет гарантии, что не будет конфликтов имен между различными интерфейсами, хотя они маловероятны, поскольку даже первые 128 бит SHA-256 обеспечивают достаточную [устойчивость к коллизиям](https://en.wikipedia.org/wiki/Collision_resistance).

:::

### Постоянные переменные состояния {#variables}

Контракты могут определять переменные состояния, которые сохраняются между вызовами контракта. Контракты в TON [платят аренду](https://docs.ton.org/develop/smart-contracts/fees#storage-fee) пропорционально объему потребляемого ими постоянного пространства, поэтому приветствуются [компактные представления через сериализацию](/book/integers#serialization).

```tact
contract Example {
    // постоянные переменные состояния
    val: Int; // Int
    val32: Int as uint32; // Int сериализован в 32-битный unsigned
    mapVal: map<Int, Int>; // Int ключи к Int значениям
    optVal: Int?; // Int или null
}
```

Переменные состояния должны иметь значение по умолчанию или инициализироваться в функции [`init(){:tact}`](#init-function), которая запускается при развертывании контракта. Единственное исключение — постоянные переменные состояния типа [`map<K, V>{:tact}`](/book/maps), поскольку они по умолчанию инициализируются пустыми.

:::note

  Обратите внимание, что Tact также поддерживает локальные переменные с непостоянным состоянием, см.: [объявление переменной](/book/statements#let).

:::

### Константы контракта {#constants}

В отличие от [переменных](#variables), константы не могут изменяться. Их значения вычисляются во время _компиляции_ и не могут изменяться во время выполнения.

Между константами, определенными вне контракта (глобальные константы) и внутри контракта (константы контракта) нет большой разницы. Те, которые определены вне, могут использоваться другими контрактами в вашем проекте.

Инициализация констант должна быть относительно простой и полагаться только на значения, известные во время компиляции. Например, если вы добавите два числа, компилятор вычислит результат во время сборки и поместит его в ваш скомпилированный код.

Вы можете читать константы как в [приёмниках](#receiver-functions), так и в [получателях](#getter-functions).

В отличие от [переменных контракта](#variables), **константы контракта не занимают место в постоянном состоянии**. Их значения хранятся непосредственно в коде [`Cell{:tact}`](/book/cells#cells) контракта.

```tact
// глобальные константы вычисляются во время компиляции и не могут изменяться
const GlobalConst1: Int = 1000 + ton("42") + pow(10, 9);

contract Example {
    // константы контракта также вычисляются во время компиляции и не могут изменяться
    const ContractConst1: Int = 2000 + ton("43") + pow(10, 9);

    // константы контракта могут быть простой альтернативой перечислениям
    const StateUnpaid: Int = 0;
    const StatePaid: Int = 1;
    const StateDelivered: Int = 2;
    const StateDisputed: Int = 3;

    get fun sum(): Int {
        // доступ к константам из любой точки мира
        return GlobalConst1 + self.ContractConst1 + self.StatePaid;
    }
}
```

Подробнее о константах читайте на их специальной странице: [константы](/book/constants).

### Функция конструктора `init()` {#init-function}

При развертывании контракта запускается функция конструктора `init(){:tact}`.

Если в контракте есть какие-либо [переменные постоянного состояния](#variables) без указанных значений по умолчанию, он должен инициализировать их в этой функции.

```tact
contract Example {
    // постоянные переменные состояния
    var1: Int = 0; // initialized with default value 0
    var2: Int;     // must be initialized in the init() function

    // функция-конструктор
    init() {
        self.var2 = 42;
    }
}
```

Если в контракте нет постоянных переменных состояния или у всех них указано значение по умолчанию, он может вообще опустить объявление функции `init(){:tact}`. Это связано с тем, что если явно не объявлено, пустая функция `init(){:tact}` присутствует по умолчанию во всех контрактах.

Ниже приведен пример допустимого пустого контракта:

```tact
contract IamEmptyAndIKnowIt {}
```

Для вашего удобства список параметров `init(){:tact}` может иметь завершающую запятую:

```tact
contract TheySeeMeTrailing {
    init(
        param1: Int,
        param2: Int, // запятая в конце разрешена
    ) {
        // ...
    }
}
```

:::note

  Чтобы получить начальное состояние целевого контракта во [внутренних функциях](#internal-functions), [приёмниках](#receiver-functions) или [получателях](#getter-functions), используйте выражение [`initOf{:tact}`](/book/expressions#initof).

:::

### Функции получения

[Функции получения](/book/functions#getter-functions) **не доступны из других контрактов и экспортируются только в off-chain мир**.

Кроме того, **получатели не могут изменять переменные состояния контракта**, а только считывают их значения и используют их в выражениях.

```tact
contract HelloWorld {
    foo: Int;

    init() {
        self.foo = 0;
    }

    // функция получения с возвращаемым типом Int
    get fun foo(): Int {
        return self.foo; // нельзя изменить self.foo
    }
}
```

Подробнее о них читайте в специальном разделе: [Функции получения](/book/functions#getter-functions)

### Функции приемника

[Функции приёмника](/book/functions#receiver-functions) в Tact могут быть одного из следующих трех видов:

- [`receive(){:tact}`](/book/receive), которые получают внутренние сообщения (из других контрактов).
- [`bounced(){:tact}`](/book/bounced), которые вызываются, когда исходящее сообщение из этого контракта возвращается.
- [`external(){:tact}`](/book/external), которые не имеют отправителя и могут быть отправлены кем угодно в мире.

```tact
message CanBounce {
    counter: Int;
}

contract HelloWorld {
    counter: Int;

    init() {
        self.counter = 0;
    }

    get fun counter(): Int {
        return self.counter;
    }

    // внутренний получатель сообщений, который отвечает на строковое сообщение "increment"
    receive("increment") {
        self.counter += 1;

        // отправка сообщения обратно отправителю
        send(SendParameters{
            to: sender(),
            value: 0,
            mode: SendRemainingValue | SendIgnoreErrors,
            body: CanBounce{counter: self.counter}.toCell(),
        });
    }

    // получатель возвращенного сообщения, который вызывается, когда сообщение возвращается обратно в этот контракт
    bounced(src: bounced<MsBounced>) {
        self.counter = 0; // сбросить счетчик в случае возврата сообщения
    }

    // внешний получатель сообщений, который отвечает на сообщение off-chain "hello, it's me"
    external("hello, it's me") {
        // невозможно ответить, так как нет отправителя!
        self.counter = 0;
    }
}
```

Обозначение параметра функции получателя символом подчеркивания "_{:tact}" означает, что его значение считается неиспользуемым и отбрасывается. Это полезно, когда вам не нужно проверять полученное сообщение и вы хотите, чтобы оно передавало только определенный код операции:

```tact
message(42) UniverseCalls {}

contract Пример {
    receive(_: UniverseCalls) {
        // Получено сообщение с opcode 42
    }
}
```

### Внутренние функции

Эти функции ведут себя аналогично закрытым методам в популярных объектно-ориентированных языках — они являются внутренними для контрактов и могут быть вызваны путем добавления к ним префикса специального [идентификатора `self{:tact}`](#self). Вот почему внутренние функции иногда можно называть "методами контракта".

Внутренние функции могут обращаться к [постоянным переменным состояния](#variables) и [константам](#constants) контракта.

Их можно вызывать только из [приёмников](#receiver-functions), [получателей](#getter-functions) и других внутренних функций, но не из других контрактов или [`init(){:tact}`](#init-function).

```tact
contract Functions {
    val: Int = 0;

    // этот метод контракта может быть вызван только из этого контракта и получить доступ
    fun onlyZeros() {
        require(self.val == 0, "Only zeros are permitted!");
    }

    // функция-приемник, которая вызывает внутреннюю функцию onlyZeros
    receive("only zeros") {
        self.onlyZeros();
    }
}
```

:::note

  Обратите внимание, что Tact также поддерживает другие виды функций, см.: [Функции](/book/functions).

:::

[p]: /book/types#primitive-types
[признак]: /book/types#traits
[bp]: https://github.com/ton-org/blueprint
[bp-config]: https://github.com/ton-org/blueprint/tree/main?tab=readme-ov-file#configuration
