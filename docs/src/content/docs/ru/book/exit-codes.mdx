---
title: Коды выхода
description: Код выхода — это 32-битное целое число со знаком, которое указывает, была ли фаза вычислений или действий транзакции успешной, а если нет — содержит код произошедшего исключения
---

import { Badge } from '@astrojs/starlight/components';

Каждая транзакция в блокчейне TON состоит из [нескольких фаз](https://docs.ton.org/learn/tvm-instructions/tvm-overview#transactions-and-phases). _Код выхода_ — это $32$-битное целое число со знаком, которое указывает, была ли фаза [вычислений](#compute) или [действий](#action) транзакции успешной, а если нет — содержит код произошедшего исключения. Каждый код выхода представляет свое собственное исключение или итоговое состояние транзакции.

Коды выхода $0$ и $1$ указывают на нормальное (успешное) выполнение [фазы вычислений](#compute). Код выхода (или [результат](#action)) $0$ указывает на нормальное (успешное) выполнение [фазы действия](#action). Любой другой код выхода указывает на то, что произошло определенное исключение и транзакция не была успешной тем или иным образом, т. е. транзакция была отменена или входящее сообщение вернулось обратно.

Блокчейн TON резервирует значения кодов выхода от $0$ до $127$, в то время как Tact использует коды выхода от $128$ до $255$. Обратите внимание, что коды выхода, используемые Tact, указывают на ошибки контракта, которые могут возникнуть при использовании сгенерированного Tact кода FunC, и поэтому выбрасываются в [фазе вычисления](#compute) транзакции, а не во время компиляции.

Диапазон от $256$ до $65535$ свободен для кодов выхода, определенных разработчиком.

:::note

  В то время как код выхода (или [результат](#action)) представляет собой $32$-битное целое число со знаком в блокчейне TON, попытка [выдать](/ref/core-debug) код выхода за пределы $16$-битного целого числа без знака ($0 - 65535$) вызовет ошибку с [кодом выхода 5](#5). Это сделано намеренно, чтобы предотвратить искусственное создание некоторых кодов выхода, таких как [код выхода -14](#-14).

:::

## Таблица кодов выхода {#table}

В следующей таблице перечислены коды выхода с указанием источника (где он может возникнуть) и кратким описанием для каждого. В таблице не указан код выхода [`require()`](/ref/core-debug#require), поскольку он генерирует его в зависимости от конкретного сообщения об ошибке [строки][p]. Чтобы увидеть такие коды, перейдите к разделу [Код выхода из отчета](/book/compile#exit-codes).

| Код выхода        | Источник                                    | Краткое описание                                                                                                         |
| :---------------- | :------------------------------------------ | :----------------------------------------------------------------------------------------------------------------------- |
| [$0$](#0)         | Фазы [вычислений][c] и [действий][a]        | Стандартный код выхода успешного выполнения.                                                                             |
| [$1$](#1)         | [Фаза вычисления][c]                        | Альтернативный код выхода успешного выполнения. Зарезервирован, но не происходит.                                        |
| [$2$](#2)         | [Фаза вычисления][c]                        | Переполнение стека.                                                                                                      |
| [$3$](#3)         | [Фаза вычисления][c]                        | Переполнение стека.                                                                                                      |
| [$4$](#4)         | [Фаза вычисления][c]                        | Переполнение целого числа.                                                                                               |
| [$5$](#5)         | [Фаза вычисления][c]                        | Ошибка проверки диапазона — некоторое целое число выходит за пределы ожидаемого диапазона.                               |
| [$6$](#6)         | [Фаза вычисления][c]                        | Недопустимый код операции [TVM][tvm].                                                                                    |
| [$7$](#7)         | [Фаза вычисления][c]                        | Ошибка проверки типа.                                                                                                    |
| [$8$](#8)         | [Фаза вычисления][c]                        | Переполнение ячейки.                                                                                                     |
| [$9$](#9)         | [Фаза вычисления][c]                        | Неполное заполнение ячейки.                                                                                              |
| [$10$](#10)       | [Фаза вычисления][c]                        | Ошибка словаря.                                                                                                          |
| [$11$](#11)       | [Фаза вычисления][c]                        | Описано в документации [TVM][tvm] как "Неизвестная ошибка, может быть выдана пользовательскими программами".             |
| [$12$](#12)       | [Фаза вычисления][c]                        | Фатальная ошибка. Выдается [TVM][tvm] в ситуациях, которые считаются невозможными.                                       |
| [$13$](#13)       | [Фаза вычисления][c]                        | Ошибка "Нет газа".                                                                                                       |
| [$-14$](#-14)     | [Фаза вычисления][c]                        | То же, что и $13$. Отрицательно, поэтому [не может быть подделано](#13).                                                 |
| [$14$](#14)       | [Фаза вычисления][c]                        | Ошибка виртуализации виртуальной машины. Зарезервировано, но никогда не выдается.                                        |
| [$32$](#32)       | [Фаза действия][a]                          | Список действий недействителен.                                                                                          |
| [$33$](#33)       | [Фаза действия][a]                          | Список действий слишком длинный.                                                                                         |
| [$34$](#34)       | [Фаза действия][a]                          | Действие недействительно или не поддерживается.                                                                          |
| [$35$](#35)       | [Фаза действия][a]                          | Неверный исходный адрес в исходящем сообщении.                                                                           |
| [$36$](#36)       | [Фаза действия][a]                          | Неверный адрес назначения в исходящем сообщении.                                                                         |
| [$37$](#37)       | [Фаза действия][a]                          | Недостаточно Toncoin.                                                                                                    |
| [$38$](#38)       | [Фаза действия][a]                          | Недостаточно дополнительных валют.                                                                                       |
| [$39$](#39)       | [Фаза действия][a]                          | Исходящее сообщение не помещается в ячейку после перезаписи                                                              |
| [$40$](#40)       | [Фаза действия][a]                          | Невозможно обработать сообщение — недостаточно средств, сообщение слишком большое или его глубина Меркла слишком велика. |
| [$41$](#41)       | [Фаза действия][a]                          | Ссылка на библиотеку равна нулю во время действия по изменению библиотеки.                                               |
| [$42$](#42)       | [Фаза действия][a]                          | Ошибка действия по изменению библиотеки.                                                                                 |
| [$43$](#43)       | [Фаза действия][a]                          | Превышено максимальное количество ячеек в библиотеке или максимальная глубина дерева Меркла.                             |
| [$50$](#50)       | [Фаза действия][a]                          | Размер состояния аккаунта превысил лимит.                                                                                |
| [$128$](#128)     | Компилятор Tact ([Фаза вычисления][c])      | Исключение нулевой ссылки.                                                                                               |
| [$129$](#129)     | Компилятор Tact ([Фаза вычисления][c])      | Неверный префикс сериализации.                                                                                           |
| [$130$](#130)     | Компилятор Tact ([Фаза вычисления][c])      | Неверное входящее сообщение — нет получателя для кода операции полученного сообщения.                                    |
| [$131$](#131)     | Компилятор Tact ([Фаза вычисления][c])      | Ошибка ограничений. Зарезервировано, но никогда не выдавалось.                                                           |
| [$132$](#132)     | Компилятор Tact ([Фаза вычисления][c])      | Доступ запрещен — сообщение на контракт отправил кто-то другой, а не владелец.                                           |
| [$133$](#133)     | Компилятор Tact ([Фаза вычисления][c])      | Контракт остановлен. Зарезервировано, но никогда не выдавалось.                                                          |
| [$134$](#134)     | Компилятор Tact ([Фаза вычисления][c])      | Недопустимый аргумент.                                                                                                   |
| [$135$](#135)     | Компилятор Tact ([Фаза вычисления][c])      | Код контракта не найден.                                                                                                 |
| ~~[$136$](#136)~~ | ~~Компилятор Tact ([Фаза вычисления][c])~~  | ~~Недопустимый адрес.~~ Удалено с версии Tact 1.6 (еще не выпущено)                                                      |
| ~~[$137$](#137)~~ | ~~Компилятор Tact ([Фаза вычисления][c])~~  | ~~Поддержка мастерчейна для этого контракта не включена.~~ Удалено с версии Tact 1.6 (еще не выпущено)                   |

:::note

  Достаточно часто вы можете столкнуться с кодом выхода $65535$ (или `0xffff`), что обычно означает то же самое, что и [код выхода 130](#130) — полученный код операции неизвестен контракту, поскольку не было получателей, ожидающих его. При написании контрактов код выхода $65535$ устанавливается разработчиками, а не [TVM][tvm] или компилятором Tact.

:::

[c]: https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase
[a]: https://docs.ton.org/learn/tvm-instructions/tvm-overview#transactions-and-phases

## Коды выхода в проектах Blueprint {#blueprint}

В тестах [Blueprint][bp] коды выхода из [фазы вычислений](#compute) указываются в поле `exitCode` аргумента объекта для метода `toHaveTransaction(){:typescript}` средства сопоставления `expect(){:typescript}`. Поле для кодов [результата](#action) (кодов выхода из [фазы действий](#action)) в том же методе `toHaveTransaction(){:typescript}` называется `actionResultCode`.

:::note

  Подробнее об ожидании определенных кодов выхода читайте здесь: [Транзакции с преднамеренными ошибками](/book/debug#tests-errors).

:::

Кроме того, можно посмотреть на результат [отправки сообщения в контракт](/book/debug#tests-send) и узнать фазы каждой транзакции и их значения, включая коды выхода (или результата) для [фазы вычислений](#compute) (или [фазы действий](#action)).

Обратите внимание, что для этого вам придется выполнить несколько проверок типов перед этим:

```typescript
it('tests something, you name it', async () => {
  // Отправляем определенное сообщение в наш контракт и сохраняем результаты
  const res = await your_contract_name.send(…);

  // Теперь у нас есть доступ к массиву выполненных транзакций,
  // причем вторая (индекс 1) — это та, которую мы ищем
  const tx = res.transactions[1]!;

  // Чтобы сделать с ней что-то полезное, давайте убедимся, что ее тип — 'generic'
  // и что фаза вычислений в ней не была пропущена
  if (tx.description.type === "generic"
      && tx.description.computePhase.type === "vm") {
    // Наконец, мы можем свободно заглянуть в транзакцию для получения общих сведений,
    // таких как вывод кода выхода фазы вычислений, если мы этого хотим
    console.log(tx.description.computePhase.exitCode);
  }

  // ...
});
```

## Фазы вычислений и действий

### 0: Нормальное завершение {#0}

Этот код выхода (или [результат](#action)) указывает на успешное завершение фазы [вычислений](#compute) (или [действий](#action)) транзакции.

## Фаза вычислений {#compute}

Инициализация [TVM][tvm] и все вычисления происходят в [фазе вычислений][c].

Если фаза вычислений завершается неудачно (результирующий код выхода не [$0$](#0) или [$1$](#1)), транзакция пропускает [фазу действий](#action) и переходит в фазу возврата. В ней формируется сообщение об отказе для транзакций, инициированных входящим сообщением.

### 1: Альтернативное завершение {#1}

Это альтернативный код завершения для успешного выполнения [фазы вычислений](#compute). Зарезервирован, но никогда не происходит.

### 2: Переполнение стека {#2}

Если какая-то операция потребила больше элементов, чем было в стеке, выдается ошибка с кодом завершения $2$: `Переполнение стека`.

```tact
asm fun drop() { DROP }

contract Loot {
    receive("I solemnly swear that I'm up to no good") {
        try {
            // Удаляет 100 элементов из стека, вызывая переполнение
            repeat (100) { drop() }
        } catch (exitCode) {
            // exitCode is 2
        }
    }
}
```

:::note[Useful Полезные ссылки:]

  [TVM — это стековая машина](https://docs.ton.org/learn/tvm-instructions/tvm-overview#tvm-is-a-stack-machine) в документации TON.

:::

### 3: Переполнение стека {#3}

Если в продолжение замыкания скопировано слишком много элементов, выдается ошибка с кодом выхода $3$: `Переполнение стека`. Встречается редко, если только вы не глубоко в окопах [ассемблирования Fift и TVM](https://docs.ton.org/develop/fift/fift-and-tvm-assembly):

```tact
// Помните, дети, не пытайтесь переполнить стек дома!
asm fun stackOverflow() {
    x{} SLICE        // s
    BLESS            // c
    0 SETNUMARGS     // c'
    2 PUSHINT        // c' 2
    SWAP             // 2 c'
    1 -1 SETCONTARGS // ← это взрывается
}

contract ItsSoOver {
    receive("Я торжественно клянусь, что я замышляю ничего хорошего") {
        try {
            stackOverflow();
        } catch (exitCode) {
            // exitCode is 3
        }
    }
}
```

:::note[Useful Полезные ссылки:]

  [TVM — это стековая машина](https://docs.ton.org/learn/tvm-instructions/tvm-overview#tvm-is-a-stack-machine) в документации TON.

:::

### 4: Целочисленное переполнение {#4}

Если значение в расчете выходит за пределы диапазона от $-2^{256}$ до $2^{256} - 1$ включительно или происходит попытка [деления](/book/operators#binary-divide) или [по модулю](/book/operators#binary-modulo) на ноль, выдается ошибка с кодом выхода $4$: `Целочисленное переполнение`.

```tact
let x = -pow(2, 255) - pow(2, 255); // -2^{256}

try {
    -x; // целочисленное переполнение при отрицании
        // поскольку максимальное положительное значение равно 2^{256} - 1
} catch (exitCode) {
    // exitCode is 4
}

try {
    x / 0; // деление на ноль!
} catch (exitCode) {
    // exitCode is 4
}

try {
    x * x * x; // целочисленное переполнение!
} catch (exitCode) {
    // exitCode is 4
}

// Также может возникнуть целочисленное переполнение при выполнении:
// сложения (+),
// вычитания (-),
// деления (/) на отрицательное число или остатка (%) на ноль
```

### 5: Целое число вне диапазона {#5}

Ошибка проверки диапазона — некоторое целое число выходит за пределы ожидаемого диапазона. Т.е. любая попытка сохранить непредвиденный объем данных или указать значение, выходящее за пределы диапазона, выдает ошибку с кодом выхода $5$: `Целое число вне диапазона`.

Примеры указания значения, выходящего за пределы:

```tact
try {
    // Повторение работает только в диапазоне от 1 до 2^{31} - 1
    // и любое допустимое целое значение, большее этого, вызывает ошибку с кодом выхода 5
    repeat (pow(2, 55)) {
        dump("smash. logs. I. must.");
    }
} catch (exitCode) {
    // exitCode равен 5
}

try {
    // Функция Builder.storeUint() может использовать только до 256 бит, поэтому 512 слишком много::
    let s: Slice = beginCell().storeUint(-1, 512).asSlice();
} catch (exitCode) {
    // exitCode равен 5
}
```

### 6: Недопустимый код операции {#6}

Если указать инструкцию, которая не определена в текущей версии [TVM][tvm] или попытаться установить неподдерживаемую [кодовую страницу](https://docs.ton.org/v3/documentation/tvm/tvm-overview#tvm-state), будет выдана ошибка с кодом выхода $6$: `Недопустимый код операции`.

```tact
// Такой кодовой страницы нет, и попытка ее установить не удалась
asm fun invalidOpcode() { 42 SETCP }

contract OpOp {
    receive("Я торжественно клянусь, что не замышляю ничего хорошего") {
        try {
            invalidOpcode();
        } catch (exitCode) {
            // exitCode равен 6
        }
    }
}
```

### 7: Ошибка проверки типа {#7}

Если аргумент примитива имеет неверный тип значения или есть какое-либо другое несоответствие типов во время [фазы вычисления](#compute), выдается ошибка с кодом выхода $7$: `Ошибка проверки типа`.

```tact
// Фактический тип возвращаемого значения не соответствует объявленному
asm fun typeCheckError(): map<Int, Int> { 42 PUSHINT }

contract VibeCheck {
    receive("Я торжественно клянусь, что не замышляю ничего хорошего") {
        try {
            // Нулевой индекс не существует
            typeCheckError().get(0)!!;
        } catch (exitCode) {
            // exitCode равен 7
        }
    }
}
```

### 8: Переполнение ячейки {#8}

Со страницы [ячейки, строители и срезы](/book/cells#cells) из книги:

> [`Cell{:tact}`][cell] - это [примитив][p] и структура данных, которая [обычно](/book/cells#cells-kinds) состоит из $1023$ непрерывно расположенных битов и до $4$ ссылок (refs) на другие ячейки.

Для построения [`Cell{:tact}`][cell], используется [`Builder{:tact}`][builder]. Если вы попытаетесь сохранить более $1023$ битов данных или более $4$ ссылок на другие ячейки, возникнет ошибка с кодом выхода $8$: `Переполнение ячейки`.

Эта ошибка может быть вызвана [ручным созданием](/book/cells#cnp-manually) ячеек с помощью [соответствующих методов `.loadSomething()`](/ref/core-cells) или при [использовании структур и сообщений и их удобных методов](/book/cells#cnp-structs).

```tact
// Слишком много бит
try {
    let data = beginCell()
        .storeInt(0, 250)
        .storeInt(0, 250)
        .storeInt(0, 250)
        .storeInt(0, 250)
        .storeInt(0, 24) // 1024 бита!
        .endCell();
} catch (exitCode) {
    // exitCode равен 8
}

// Слишком много ссылок
try {
    let data = beginCell()
        .storeRef(emptyCell())
        .storeRef(emptyCell())
        .storeRef(emptyCell())
        .storeRef(emptyCell())
        .storeRef(emptyCell()) // 5 ссылок!
        .endCell();
} catch (exitCode) {
    // exitCode равен 8
}
```

### 9: Незаполненная ячейка {#9}

Со страницы [ячейки, конструкторы и срезы](/book/cells#cells) из книги:

> `Cell{:tact}` — это [примитив][p] и структура данных, которая [обычно](/book/cells#cells-kinds) состоит из $1023$ непрерывно расположенных битов и до $4$ ссылок (refs) на другие ячейки.

Для разбора [`Cell{:tact}`][cell] используется [`Slice{:tact}`][slice]. Если вы попытаетесь загрузить больше данных или ссылок, чем содержит `Slice{:tact}`, возникнет ошибка с кодом выхода $9$: `Незаполненная ячейка`.

Наиболее распространенной причиной этой ошибки является несоответствие между ожидаемой и фактической структурой памяти ячеек, поэтому рекомендуется [использовать структуры и сообщения для анализа](/book/cells#cnp-structs) ячеек вместо [ручного анализа](/book/cells#cnp-manually) с помощью [соответствующих методов `.loadSomething()`](/ref/core-cells).

```tact
// Слишком мало би
try {
    emptySlice().loadInt(1); // 0 бит!
} catch (exitCode) {
    // exitCode равен 9
}

// Слишком мало ссылок
try {
    emptySlice().loadRef(); // 0 ссылок!
} catch (exitCode) {
    // exitCode равен 9
}
```

### 10: Ошибка словаря {#10}

В Tact тип [`map<K, V>{:tact}`](/book/maps) является абстракцией над [словарями карт "хэшей" FunC](https://docs.ton.org/develop/func/dictionaries#hashmap) и базовым [типом`HashmapE`](https://docs.ton.org/develop/data-formats/tl-b-types#hashmap) [TL-B][tlb] и [TVM][tvm].

Если происходит некорректная манипуляция словарями, например, неправильные предположения об их структуре памяти, выдается ошибка с кодом выхода $10$: `Ошибка словаря`. Обратите внимание, что Tact предотвращает возникновение этой ошибки, если только вы не выполните [сборку Fift и TVM](https://docs.ton.org/develop/fift/fift-and-tvm-assembly) самостоятельно:

```tact
/// Предварительно вычисленный словарь Int в Int с двумя записями — 0: 0 и 1: 1
const cellWithDictIntInt: Cell = cell("te6cckEBBAEAUAABAcABAgPQCAIDAEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMLMbT1U=");

/// Пытается предварительно загрузить словарь из среза как map<Int, Cell>
asm fun toMapIntCell(x: Slice): map<Int, Cell> { PLDDICT }

contract DictPic {
    receive("Я торжественно клянусь, что замышляю что-то нехорошее") {
        try {
            // Словарь Int в Int неверно интерпретируется как map<Int, Cell>
            let m: map<Int, Cell> = toMapIntCell(cellWithDictIntInt.beginParse());

            // И ошибка происходит только когда мы к нему прикасаемся
            m.get(0)!!;
        } catch (exitCode) {
            // exitCode равен 10
        }
    }
}
```

### 11: "Неизвестная" ошибка {#11}

Описана в документации [TVM][tvm] как "Неизвестная ошибка, может быть вызвана пользовательскими программами", хотя чаще всего используется для проблем с очередью отправки сообщения или проблем с [get-методами](https://docs.ton.org/develop/smart-contracts/guidelines/get-methods).

```tact
try {
    // В отличие от nativeSendMessage, который использует SENDRAWMSG, этот использует SENDMSG,
    // и поэтому терпит неудачу на этапе вычислений, когда сообщение неправильно сформировано
    nativeSendMessageReturnForwardFee(emptyCell(), 0);
} catch (exitCode) {
    // exitCode равен 11
}
```

### 12: Фатальная ошибка {#12}

Фатальная ошибка. Выдается TVM в ситуациях, которые считаются невозможными.

### 13: Ошибка отсутствия газа {#13}

Если для завершения вычислений в [фазе вычислений](#compute) недостаточно газа, выдается ошибка с кодом выхода $13$: `Ошибка отсутствия газа`.

Но этот код не отображается сразу как есть — вместо этого применяется побитовая операция НЕ, которая изменяет значение с $13$ на $-14$. И только затем отображается код.

Это сделано для того, чтобы предотвратить искусственное создание результирующего кода ($-14$) в пользовательских контрактах, поскольку все функции, которые могут [выдавать код выхода](/ref/core-debug), могут указывать только целые числа в диапазоне от $0$ до $65535$ включительно.

```tact
try {
    repeat (pow(2, 31) - 1) {}
} catch (exitCode) {
    // exitCode равен -14
}
```

### \-14: Ошибка нехватки газа {#-14}

См. [код выхода 13](#13).

### 14: Ошибка виртуализации {#14}

Ошибка виртуализации, связанная с [отсеченными ячейками ветвей](/book/cells#cells-kinds). Зарезервировано, но никогда не выдается.

## Фаза действия {#action}

[Фаза действия][a] обрабатывается после успешного выполнения [фазы вычисления](#compute). Она пытается выполнить действия, сохраненные в списке действий [TVM][tvm] во время фазы вычисления.

Некоторые действия могут завершиться ошибкой во время обработки, в этом случае эти действия могут быть пропущены или вся транзакция может быть отменена в зависимости от режима действий. Код, указывающий на результирующее состояние [фазы действия][a], называется _кодом результата_. Поскольку это также $32$-битное целое число со знаком, которое по сути выполняет ту же функцию, что и _код выхода_ [фазы вычисления](#compute), код результата также принято называть кодом выхода.

### 32: Недействительный список действий {#32}

Если список действий содержит [экзотические ячейки](/book/cells#cells-kinds), ячейка входа действия не имеет ссылок или какая-то ячейка входа действия не может быть проанализирована, выдается ошибка с кодом выхода $32$: `Недействительный список действий`.

:::note

  Помимо этого кода выхода есть логический флаг `valid`, который вы можете найти в `description.actionPhase.valid` в результатах транзакции при работе с [Sandbox и Blueprint](#blueprint). Транзакция может установить этот флаг в `false`, даже если есть какой-то другой код выхода, выданный из фазы действия.

:::

### 33: Список действий слишком длинный {#33}

Если в очереди на выполнение находится более $255$ действий, [фаза действия](#action) выдаст ошибку с кодом выхода $33$: `Список действий слишком длинный`.

```tact
// Например, давайте попытаемся поставить в очередь резервирование определенного количества nanoToncoin
// Это не приведет к сбою в фазе вычислений, но приведет к коду выхода 33 в фазе действия
repeat (256) {
    nativeReserve(ton("0.001"), ReserveAtMost);
}
```

### 34: Недопустимое или неподдерживаемое действие {#34}

В настоящий момент поддерживается только четыре действия: изменение кода контракта, отправка сообщения, резервирование определенного количества [nanoToncoin](/book/integers#nanotoncoin) и изменение ячейки библиотеки. Если есть какая-либо проблема с указанным действием (недопустимое сообщение, неподдерживаемое действие и т. д.), выдается ошибка с кодом выхода $34$: `Недопустимое или неподдерживаемое действие`.

```tact
// Например, давайте попробуем отправить неправильно сформированное сообщение:
nativeSendMessage(emptyCell(), 0); // не даст сбоя на этапе вычислений,
                                   // но приведет к коду выхода 34 на этапе действий
```

### 35: Недопустимый адрес источника в исходящем сообщении {#35}

Если адрес источника в исходящем сообщении не равен [`addr_none`](https://docs.ton.org/develop/data-formats/msg-tlb#addr_none00) или адресу контракта, инициировавшего это сообщение, выдается ошибка с кодом выхода $35$: `Недопустимый адрес источника в исходящем сообщении`.

### 36: Недопустимый адрес назначения в исходящем сообщении {#36}

Если адрес назначения в исходящем сообщении недопустим, например он не соответствует схемам [TL-B][tlb], содержит неизвестный идентификатор воркчейна или имеет недопустимую длину для данного воркчейна, выдается ошибка с кодом выхода $36$: `Недопустимый адрес назначения в исходящем сообщении`.

:::note

  Если установлен [необязательный флаг +2](/book/message-mode#optional-flags), эта ошибка не будет выдана и данное сообщение не будет отправлено.

:::

### 37: Недостаточно Toncoin {#37}

Если все средства входящего сообщения с установленным [базовым режимом 64](/book/message-mode#base-modes) уже израсходованы и недостаточно средств для оплаты невыполненного действия, или макет [TL-B][tlb] предоставленного значения ([`CurrencyCollection`](https://docs.ton.org/develop/data-formats/msg-tlb#currencycollection)) недействителен, или недостаточно средств для оплаты [комиссий за пересылку](https://docs.ton.org/develop/smart-contracts/guidelines/processing) или недостаточно средств после вычета комиссий, выдается ошибка с кодом выхода $37$: `Недостаточно Toncoin`.

:::note

  Если установлен [необязательный флаг +2](/book/message-mode#optional-flags), эта ошибка не будет выдана, и данное сообщение не будет отправлено.

:::

### 38: Недостаточно дополнительных валют {#38}

Помимо собственной валюты Toncoin, блокчейн TON поддерживает до $2^{32}$ дополнительных валют. Они отличаются от создания новых [жетонов](/cookbook/jettons), поскольку дополнительные валюты поддерживаются изначально — потенциально можно просто указать дополнительную [`HashmapE`](https://docs.ton.org/develop/data-formats/tl-b-types#hashmap) дополнительных сумм валют в дополнение к сумме Toncoin во внутреннем сообщении другому контракту. В отличие от жетонов, дополнительные валюты можно только хранить и передавать, и они не имеют никакой другой функциональности.

На данный момент **нет дополнительных валют** в блокчейне TON, но код выхода $38$ в случаях, когда недостаточно дополнительных валют для отправки указанного количества, уже зарезервирован: `Недостаточно дополнительных валют`.

:::note[Useful Полезные ссылки:]

  [Дополнительные валюты](https://docs.ton.org/develop/dapps/defi/coins) в документации TON.\
[Создание дополнительных валют](https://docs.ton.org/develop/research-and-development/minter-flow) в документации TON.

:::

### 39: Исходящее сообщение не помещается в ячейку {#39}

При обработке сообщения блокчейн TON пытается упаковать его в соответствии со [схемами TL-B](https://docs.ton.org/develop/data-formats/msg-tlb), и если это не удается, выдается ошибка с кодом выхода $39$: `Исходящее сообщение не помещается в ячейку`.

:::note

  Если попытки отправить сообщение не удаются несколько раз и установлен [необязательный флаг +2](/book/message-mode#optional-flags), эта ошибка не будет выдана, и данное сообщение не будет отправлено.

:::

### 40: Невозможно обработать сообщение {#40}

Если для обработки всех ячеек в сообщении недостаточно средств, сообщение слишком большое или его глубина Меркла слишком велика, выдается ошибка с кодом выхода $40$: `Невозможно обработать сообщение`.

:::note

  Если установлен [необязательный флаг +2](/book/message-mode#optional-flags), эта ошибка не будет выдана, и данное сообщение не будет отправлено.

:::

### 41: Ссылка на библиотеку равна нулю {#41}

Если ссылка на библиотеку была необходима во время действия по изменению библиотеки, но она была равна нулю, выдается ошибка с кодом выхода $41$: `Ссылка на библиотеку равна нулю`.

### 42: Ошибка действия по изменению библиотеки {#42}

Если при попытке действия по изменению библиотеки возникает ошибка, выдается ошибка с кодом выхода $42$: `Ошибка действия по изменению библиотеки`.

### 43: Превышены пределы библиотеки {#43}

Если превышено максимальное количество ячеек в библиотеке или максимальная глубина дерева Меркла, выдается ошибка с кодом выхода $43$: `Превышены пределы библиотеки`.

### 50: Размер состояния аккаунта превысил лимиты {#50}

Если состояние аккаунта (по сути, хранилище контракта) превышает любой из лимитов, указанных в [параметре конфигурации 43 блокчейна TON](https://docs.ton.org/develop/howto/blockchain-configs#param-43) к концу [фазы действия]](#action), выдается ошибка с кодом выхода $50$: `Размер состояния аккаунта превысил лимиты`.

Если конфигурация отсутствует, значения по умолчанию:

- `max_msg_bits` равно $2^{21}$ — максимальный размер сообщения в битах.
- `max_msg_cells` равно $2^{13}$ — максимальное количество [ячеек][cell], которые может занимать сообщение.
- `max_library_cells` равно $1000$ — максимальное количество [ячеек][cell], которые могут быть использованы как [ячейки ссылок библиотеки](/book/cells#cells-kinds).
- `max_vm_data_depth` равно $2^{9}$ — максимальная глубина [ячеек][cells] в сообщениях и состоянии аккаунта.
- `ext_msg_limits.max_size` равно $65535$ — максимальный размер внешнего сообщения в битах.
- `ext_msg_limits.max_depth` равно $2^{9}$ — максимальная [глубина](/book/cells#cells-representation) внешнего сообщения.
- `max_acc_state_cells` равно $2^{16}$ — максимальное количество [ячеек][cell], которые может занимать состояние аккаунта.
- `max_acc_state_bits` равно $2^{16} \* 1023$ — максимальный размер состояния аккаунта в битах.
- `max_acc_public_libraries` равно $2^{8}$ — максимальное количество [ячеек ссылок на библиотеки](/book/cells#cells-kinds), которые состояние аккаунта может использовать в мастерчейне.
- `defer_out_queue_size_limit` равно $2^{8}$ — максимальное количество исходящих сообщений, которые должны быть поставлены в очередь (относительно валидаторов и коллаторов).

## Компилятор Tact

Tact использует коды выхода от $128$ до $255$. Обратите внимание, что коды выхода, используемые Tact, указывают на ошибки контракта, которые могут возникнуть при использовании кода FunC, сгенерированного Tact, и поэтому выбрасываются в [фазе вычислений](#compute) транзакции, а не во время компиляции.

### 128: Исключение нулевой ссылки {#128}

Если есть ненулевое утверждение, например оператор [`!!{:tact}`](/book/operators#unary-non-null-assert), а проверяемое значение равно [`null{:tact}`](/book/optionals), выдается ошибка с кодом выхода $128$: `Исключение нулевой ссылки`.

```tact
let gotcha: String? = null;

try {
    // Утверждается, что значение не равно null, что не так!
    dump(gotcha!!);
} catch (exitCode) {
    // exitCode равен 128
}
```

### 129: Недопустимый префикс сериализации {#129}

Зарезервировано, но из-за ряда предыдущих проверок его нельзя выдать, если только не перехватить код контракта перед развертыванием и не изменить коды операций [сообщений][message], которые, как ожидается, будут получены в контракте.

### 130: Недопустимое входящее сообщение {#130}

Если полученное внутреннее или внешнее сообщение не обрабатывается контрактом, выдается ошибка с кодом выхода $130$: `Недопустимое входящее сообщение`. Обычно это происходит, когда у контракта нет получателя для конкретного сообщения и его префикса кода операции (32-битный целочисленный заголовок).

Рассмотрим следующий контракт:

```tact
import "@stdlib/deploy";

contract Dummy with Deployable {}
```

Если вы попытаетесь отправить любое сообщение, кроме [`Deploy{:tact}`](/ref/stdlib-deploy#deploy), предоставленного [`@stdlib/deploy`](/ref/stdlib-deploy), у контракта не будет получателя для него, и, таким образом, возникнет ошибка с кодом выхода $130$.

### 131: Ошибка ограничений {#131}

Ошибка ограничений. Зарезервировано, но никогда не выдается.

### 132: Доступ запрещен {#132}

Если вы используете [`Ownable{:tact}`](/ref/stdlib-ownable#ownable) [признак][ct] из библиотеки [`@stdlib/ownable`](/ref/stdlib-ownable), вспомогательная функция `requireOwner(){:tact}`, предоставляемая ею, выдаст ошибку с кодом выхода $132$, если отправитель входящего сообщения не будет соответствовать указанному владельцу: `Access denied`.

```tact
import "@stdlib/ownable";

contract Hal9k with Ownable {
    owner: Address;

    init(owner: Address) {
        self.owner = owner; // задать адрес владельца при развертывании
    }

    receive("Извините, Дэйв, боюсь, я не могу этого сделать.") {
        // Проверяет, что адрес отправителя сообщения равен адресу владельца,
        // и если нет — выдает ошибку с кодом выхода 132.
        self.requireOwner();

        // ... ты делаешь это сам ...
    }
}
```

### 133: Контракт остановлен {#133}

Сообщение было отправлено в остановленный контракт. Зарезервировано, но никогда не выдается.

### 134: Недопустимый аргумент {#134}

Если есть недопустимое или неожиданное значение аргумента, выдается ошибка с кодом выхода $134$: `Недопустимый аргумент`.

Вот некоторые функции в Tact, которые могут выдать ошибку с этим кодом выхода:

1. [`Int.toFloatString(digits){:tact}`](/ref/core-strings#inttofloatstring): если `digits` не находится в интервале: $0 <$ `digits` $< 78$.

2. [`String.fromBase64(){:tact}`](/ref/core-strings#stringfrombase64) и [`Slice.fromBase64(){:tact}`](/ref/core-strings#slicefrombase64): если заданная [`String{:tact}`][p] или [`Slice{:tact}`][slice] содержит символы, не входящие в Base64.

```tact
try {
    // 0 — это код NUL в ASCII, и он не является допустимым Base64
    let code: Slice = beginCell().storeUint(0, 8).asSlice().fromBase64();
} catch (exitCode) {
    // exitCode равен 134
}
```

### 135: Код контракта не найден {#135}

Если код контракта не совпадает с сохраненным в оболочках TypeScript, будет выдана ошибка с кодом выхода $135$: `Код контракта не найден`.

### 136: Недопустимый адрес {#136}

<Badge text="Удалено с Tact 1.6 (еще не выпущено)" variant="tip" size="medium"/><p/>

Значение типа [`Address{:tact}`][p] допустимо в Tact, когда:

- Оно занимает $267$ бит: $11$ бит для префикса идентификатора цепочки и $256$ бит для [самого адреса](https://docs.ton.org/learn/overviews/addresses#address-of-smart-contract).
- Он принадлежит либо к бейсчейну (ID $0$), либо к мастерчейну (ID $-1$).

Если [`Address{:tact}`][p] недействителен, будет выдана ошибка с кодом выхода $136$: `Недопустимый адрес`.

```tact
// Tact поддерживает только бейсчейн (ID 0) или мастерчейн (ID -1)
let unsupportedChainID = 1;

try {
    // Нулевой адрес не поддерживается воркчейном
    dump(newAddress(unsupportedChainID, 0));
} catch (exitCode) {
    // exitCode равен 136
}
```

### 137: Поддержка мастерчейна не включена для этого контракта {#137}

<Badge text="Удален с версии Tact 1.6 (еще не выпущен)" variant="tip" size="medium"/><p/>

До удаления любые попытки указать на мастерчейн (ID $-1$) или иным образом взаимодействовать с ним без включения поддержки мастерчейна приводят к исключению с кодом выхода $137$: `Поддержка мастерчейна не включена для этого контракта`.

```tact
let masterchainID = -1;

try {
    // Нулевой адрес в мастерчейне без установленной опции конфигурации
    dump(newAddress(masterchainID, 0));
} catch (exitCode) {
    // exitCode равен 137
}
```

[п]: /book/types#primitive-types
[тт]: /book/types#composite-types
[ячейка]: /book/cells
[конструктор]: /book/cells#builders
[кусочек]: /book/cells#slices
[сообщение]: /book/structs-and-messages#messages
[tlb]: https://docs.ton.org/develop/data-formats/tl-b-language
[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[bp]: https://github.com/ton-org/blueprint
[sb]: https://github.com/ton-org/sandbox
[jest]: https://jestjs.io
