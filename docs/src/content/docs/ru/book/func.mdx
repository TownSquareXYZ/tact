---
title: Совместимость с FunC
description: Tact компилируется в FunC и сопоставляет все свои объекты непосредственно с различными типами FunC и TL-B.
---

Сам Tact компилируется в FunC и отображает все свои сущности напрямую в различные типы FunC и TL-B.

## Преобразование типов

[Примитивные типы](/ru/book/types#primitive-types) в Tact напрямую преобразуются в типы FunC.

Все правила копирования переменных одинаковы. Одно из главных отличий заключается в том, что в Tact нет видимых операторов мутации, и большинство операций [`Slice{:tact}`](/ru/book/cells#slices) изменяют переменные на месте.

## Преобразование сериализации {#convert-serialization}

Сериализация [структур](/ru/book/structs-and-messages#structs) и [сообщений](/ru/book/structs-and-messages#messages) в Tact происходит автоматически, в отличие от FunC, где вам нужно вручную определять логику сериализации.

Алгоритм авторазметки в Tact прожорливый. Это означает, что он берет следующую переменную, вычисляет ее размер и пытается втиснуть ее в текущую ячейку. Если она не вписывается, он создает новую ячейку и продолжает. Все внутренние структуры для авторазметки сглаживаются перед выделением.

Все необязательные типы сериализуются как `Maybe` в TL-B, за исключением [`Address{:tact}`](/ru/book/types#primitive-types).

Поддержка `Either` не поддерживается, поскольку в некоторых случаях он не определяет, что следует выбирать при сериализации.

### Примеры

```tact
// _ value1:int257 = SomeValue;
struct SomeValue {
    value1: Int; // Default is 257 bits
}
```

```tact
// _ value1:int256 value2:uint32 = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: Int as uint32;
}
```

```tact
// _ value1:bool value2:Maybe bool = SomeValue;
struct SomeValue {
    value1: Bool;
    value2: Bool?;
}
```

```tact
// _ cell:^cell = SomeValue;
struct SomeValue {
    cell: Cell; // Всегда сохраняется как ссылка}
```

```tact
// _ cell:^slice = SomeValue;
struct SomeValue {
    cell: Slice; // Всегда сохраняется как ссылка
}
```

```tact
// _ value1:int256 value2:int256 value3:int256 ^[value4:int256] = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: Int as int256;
    value3: Int as int256;
    value4: Int as int256;
}
```

```tact
// _ value1:int256 value2:int256 value3:int256 ^[value4:int256] flag:bool = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: Int as int256;
    value3: Int as int256;
    flag: Bool; // Флаг записывается перед value4, чтобы избежать автоматического распределения его в следующую ячейку
    value4: Int as int256;
}
```

```tact
// _ value1:int256 value2:int256 value3:int256 ^[value4:int256 flag:bool] = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: Int as int256;
    value3: Int as int256;
    value4: Int as int256;
    flag: Bool;
}
```

```tact
// _ value1:int256 value2:^TailString value3:int256 = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: String;
    value3: Int as int256;
}
```

## Преобразование полученных сообщений в операции `op` {#convert-received-messages-to-op-operations}

Tact генерирует уникальный `op` для каждого полученного типизированного сообщения, но его можно перезаписать.

Код на FunC:

```func
() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    ;; код входящего сообщения..

    ;; Получение сообщения MessageWithGeneratedOp
    if (op == 1180414602) {
        ;; code...
    }

    ;; Получение сообщения MessageWithOverwrittenOP
    if (op == 291) {
        ;; код...
    }

}
```

В Tact это выглядит так:

```tact
message MessageWithGeneratedOp {
    amount: Int as uint32;
}

message(0x123) MessageWithOverwrittenOP {
    amount: Int as uint32;
}

contract Contract {
    // Тело контракта...

    receive(msg: MessageWithGeneratedOp) {
        // код...
    }

    receive(msg: MessageWithOverwrittenOP) {
        // код...
    }

}
```

## Преобразование `get`-методов

Вы можете выразить все, кроме `list-style-lists` в Tact, что будет совместимо с `get`-методами FunC.

### Тип возврата примитива

Если метод `get` возвращает примитив в FunC, вы можете реализовать его таким же образом в Tact.

Следующий код в FunC:

```func
int seqno() method_id {
    return 0;
}
```

В Tact преобразуется в этот:

```tact
get fun seqno(): Int {
    return 0;
}
```

### Типы возвращаемого тензора

В FunC есть разница между типом тензора `(int, int){:func}` и `(int, (int)){:func}`, но для TVM нет никаких различий, все они представляют собой стек из двух целых чисел.

Чтобы преобразовать тензор, который возвращается из метода `get` FunC, вам нужно определить [структуру](/ru/book/structs-and-messages#structs), которая имеет те же типы полей, что и тензор, и в том же порядке.

Следующий код в FunC:

```func
(int, slice, slice, cell) get_wallet_data() method_id {
    return ...;
}
```

Становится таким в Tact:

```tact
struct JettonWalletData {
    balance: Int;
    owner: Address;
    master: Address;
    walletCode: Cell;
}

contract JettonWallet {
    get fun get_wallet_data(): JettonWalletData {
        return ...;
    }
}
```

### Тип возвращаемого кортежа

В FunC, если вы возвращаете кортеж, а не тензор, вам необходимо следовать процессу для типа тензора, но определить возвращаемый тип метода `get` как необязательный.

Следующий код в FunC:

```func
[int, int] get_contract_state() method_id {
    return ...;
}
```

Становится таким в Tact:

```tact
struct ContractState {
    valueA: Int;
    valueB: Int;
}

contract StatefulContract {
    get fun get_contract_state(): ContractState? {
        return ...;
    }
}
```

### Смешанные типы возвращаемых значений кортежа и тензора

Когда некоторые из тензоров являются кортежем, вам нужно определить структуру, как на предыдущих шагах, а кортеж должен быть определен как отдельная [структура](/ru/book/structs-and-messages#structs).

Следующий код в FunC:

```func
(int, [int, int]) get_contract_state() method_id {
    return ...;
}
```

Становится таким в Tact:

```tact
struct ContractStateInner {
    valueA: Int;
    valueB: Int;
}

struct ContractState {
    valueA: Int;
    valueB: ContractStateInner;
}

contract StatefulContract {
    get fun get_contract_state(): ContractState {
        return ...;
    }
}
```

### Сопоставление аргументов

Преобразование аргументов методов `get` выполняется просто. Каждый аргумент сопоставляется _как есть_ на один из аргументов FunC, а каждый кортеж сопоставляется со [структурой](/ru/book/structs-and-messages#structs).

Следующий код в FunC:

```func
(int, [int, int]) get_contract_state(int arg1, [int,int] arg2) method_id {
    return ...;
}
```

Становится таким в Tact:

```tact
struct ContractStateArg2 {
    valueA: Int;
    valueB: Int;
}

struct ContractStateInner {
    valueA: Int;
    valueB: Int;
}

struct ContractState {
    valueA: Int;
    valueB: ContractStateInner;
}

contract StatefulContract {
    get fun get_contract_state(arg1: Int, arg2: ContractStateArg2): ContractState {
        return ContractState{
            valueA: arg1,
            valueB: ContractStateInner{
                valueA: arg2.valueA,
                valueB: arg2.valueB, // запятая в конце разрешена
            }, // запятая в конце разрешена
        };
    }
}
```
