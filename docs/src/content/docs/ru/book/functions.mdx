---
title: Функции
description: Глобальные, asm, встроенные функции, а также приёмники, получатели и функции хранения, а также множество атрибутов, которые обеспечивают большую гибкость и выразительность языка Tact
---

import { Badge } from '@astrojs/starlight/components';

Функции в языке Tact могут определяться различными способами:

- Глобальные статические функции
- Функции расширения
- Функции мутации
- Встроенные функции
- [Функции сборки](#asm)
- [Внутренние функции](/ru/book/contracts#internal-functions)
- Функции приемника
- Функции получателя

Все функции, за исключением [функции приёмника](#receiver-functions), могут иметь завершающую запятую в своих определениях (списках параметров) и вызовах (списках аргументов):

```tact
fun foo(
    a: Int, // допустима запятая в списке параметров
) {}

fun bar() {
    foo(
        5, // допустима запятая в списках аргументов!
    );
}
```

## Глобальные статические функции {#global-static-functions}

Вы можете определить глобальную функцию в любом месте вашей программы:

```tact
fun customPow(a: Int, c: Int): Int {
  let res: Int = 1;
  repeat(c) {
    res *= a;
  }
  return res;
}
```

## Виртуальная и абстрактная функции {#virtual-and-abstract-functions}

Вы можете разрешить контракту, наследующему [признаки](/ru/book/types#traits), изменять внутреннюю функцию, если у него есть ключевое слово `virtual{:tact}`, используя `override{:tact}`. Функция также может быть помечена как `abstract{:tact}`, в этом случае наследующий контракт должен определить ее реализацию:

```tact
trait FilterTrait with Ownable {
    // Виртуальные функции могут быть переопределены пользователями этого признака
    virtual fun filterMessage(): Bool {
        return sender() != self.owner;
    }

    abstract fun specialFilter(): Bool;
}

contract Filter with FilterTrait {
    // Переопределение поведения по умолчанию для FilterTrait
    override fun filterMessage(): Bool {
        return true;
    }

    override fun specialFilter(): Bool {
        return true;
    }
}
```

## Функция расширения {#extension-function}

Функции расширения позволяют реализовать расширения для любого возможного типа.

> **Предупреждение**
> Имя первого аргумента ДОЛЖНО быть названо `self`, а тип этого аргумента — это тип, который вы расширяете.

```tact
extends fun customPow(self: Int, c: Int): Int {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    return res;
}
```

## Функции мутации {#mutation-functions}

Для выполнения мутации, функция должна изменить значение `self`. Функции мутации выполняют мутацию значения, заменяя его результатом выполнения.

```tact
extends mutates fun customPow(self: Int, c: Int) {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    self = res;
}
```

## Встроенные функции {#native-functions}

Встроенные функции являются прямыми привязками функций FunC:

> **Примечание**
> Встроенные функции также могут быть функциями мутации и расширения.

```tact
@name(store_uint)
native storeUint(s: Builder, value: Int, bits: Int): Builder;

@name(load_int)
extends mutates native loadInt(self: Slice, l: Int): Int;
```

## Функции сборки, `asm` {#asm}

<Badge text="Доступно с версии Tact 1.5" variant="tip" size="medium"/><p/>

Подробнее о них читайте на специальной странице: [Функции сборки](/ru/book/assembly-functions).

## Функции приёмника {#receiver-functions}

Функции приемника — это специальные функции, которые отвечают за получение сообщений в контрактах и ​​могут быть определены только в контракте или признаке.

```tact
contract Treasure {
    // Это означает, что этот контракт может получить комментарий "Increment", и эта функция будет вызываться для таких сообщений.
    receive("Increment") {
        self.counter += 1;
    }
}
```

## Функции получения {#getter-functions}

Функции получения определяют геттеры в смарт-контрактах и ​​могут быть определены только в контракте или признаке.
Функции получения нельзя использовать для чтения состояния другого контракта: если вам нужно получить какие-то данные, вам нужно сделать это, отправив сообщение с запросом и определив получателя, который обработает ответ на запрос.

```tact
contract Treasure {
    get fun counter(): Int {
        return self.counter;
    }
}
```

### Явное разрешение коллизий идентификаторов методов

<Badge text="Доступно с версии Tact 1.6 (еще не выпущено)" option="tip" size="medium"/><p/>

Как и другие функции в контрактах TON, получатели имеют свои _уникальные_ связанные селекторы функций, которые представляют собой $19$-битные целочисленные идентификаторы со знаком, обычно называемые _идентификаторами методов_.

Идентификаторы методов получателей выводятся из их имен с использованием алгоритма [CRC16](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) следующим образом: `(crc16(<function_name>) & 0xffff) | 0x10000`. Кроме того, компилятор Tact условно резервирует некоторые идентификаторы методов для использования в [получателях поддерживаемых интерфейсов](/ru/book/contracts#interfaces), а именно: $113617$ для `supported_interfaces`, $115390$ для `lazy_deployment_completed` и $121275$ для `get_abi_ipfs`.

Иногда получатели с разными именами оказываются с одинаковым идентификатором метода. Если это произошло, вы можете либо переименовать некоторые получатели, либо вручную указать идентификатор метода как выражение [compile-time](/ru/ref/core-comptime), например:

```tact
contract ManualMethodId {
    const methodId: Int = 16384 + 42;

    get(self.methodId)
    fun methodId1(): Int {
        return self.methodId;
    }

    get(crc32("crc32") + 42 & 0x3ffff | 0x4000)
    fun methodId2(): Int {
        return crc32("crc32") + 42 & 0x3ffff | 0x4000;
    }
}
```

В отличие от получателей, идентификаторы методов для [внутренних функций](/ru/book/contracts#internal-functions) и некоторых специальных функций получаются последовательно: целые числа в диапазоне от $-4$ до $0$ включительно передаются [определенным обработчикам сообщений](https://docs.ton.org/v3/documentation/smart-contracts/func/docs/functions#special-function-names), в то время как внутренние функции нумеруются идентификаторами методов, начиная с $1$ и до $2^{14} - 1$ включительно.

Поскольку идентификаторы методов представляют собой $19$-битные целые числа со знаком, а некоторые из них зарезервированы, пользователям доступны для свободного использования только диапазоны от $-2^{18}$ до $-5$ и от $2^{14}$ до $2^{18} - 1$. Чтобы избежать коллизий, рекомендуется указывать идентификаторы методов только в этих диапазонах, избегая идентификаторов методов специфичных для Tact получателей, упомянутых выше.

[p]: /ru/book/types#primitive-types
[struct]: /ru/book/structs-and-messages#structs
[slice]: /ru/book/cells#slices
