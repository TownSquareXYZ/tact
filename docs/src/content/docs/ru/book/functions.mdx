---
title: Функции
description: Глобальные, asm, встроенные функции, а также приёмники, получатели и функции хранения, а также множество атрибутов, которые обеспечивают большую гибкость и выразительность языка Tact
---

import { Badge } from '@astrojs/starlight/components';

Функции в языке Tact могут определяться различными способами:

- Глобальные статические функции
- Функции расширения
- Изменяемые функции
- Встроенные функции
- Receiver функции
- Функции получателя

Все функции, за исключением [функции приёмника](#receiver-functions), могут иметь завершающую запятую в своих определениях (списках параметров) и вызовах (списках аргументов):

```tact
fun foo(
    a: Int, // допустима запятая в списке параметров
) {}

fun bar() {
    foo(
        5, // допустима запятая в списках аргументов!
    );
}
```

## Глобальные статические функции

Вы можете определить глобальную функцию в любом месте вашей программы:

```tact
fun customPow(a: Int, c: Int): Int {
  let res: Int = 1;
  repeat(c) {
    res *= a;
  }
  return res;
}
```

## Виртуальная и абстрактная функции

Вы можете разрешить контракту, наследующему [признаки](/book/types#traits), изменять внутреннюю функцию, если у него есть ключевое слово `virtual{:tact}`, используя `override{:tact}`. Функция также может быть помечена как `abstract{:tact}`, в этом случае наследующий контракт должен определить ее реализацию:

```tact
trait FilterTrait with Ownable {
    // Виртуальные функции могут быть переопределены пользователями этого признака
    virtual fun filterMessage(): Bool {
        return sender() != self.owner;
    }

    abstract fun specialFilter(): Bool;
}

contract Filter with FilterTrait {
    // Переопределение поведения по умолчанию для FilterTrait
    override fun filterMessage(): Bool {
        return true;
    }

    override fun specialFilter(): Bool {
        return true;
    }
}
```

## Функция расширения

Функции расширения позволяют реализовать расширения для любого возможного типа.

> **Предупреждение**
> Имя первого аргумента ДОЛЖНО быть названо `self`, а тип этого аргумента — это тип, который вы расширяете.

```tact
extends fun customPow(self: Int, c: Int): Int {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    return res;
}
```

## Изменяемые функции

Изменяемые функции выполняют мутацию значения, заменяя его результатом выполнения. Для выполнения мутации, функция должна изменить значение `self`.

```tact
extends mutates fun customPow(self: Int, c: Int) {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    self = res;
}
```

## Встроенные функции

Встроенные функции являются прямыми привязками функций FunC:

> **Примечание**
> Встроенные функции также могут быть функциями изменения и расширения.

```tact
@name(store_uint)
native storeUint(s: Builder, value: Int, bits: Int): Builder;

@name(load_int)
extends mutates native loadInt(self: Slice, l: Int): Int;
```

## Функции приёмника

Функции приемника — это специальные функции, которые отвечают за получение сообщений в контрактах и ​​могут быть определены только в контракте или признаке.

```tact
contract Treasure {
    // Это означает, что этот контракт может получить комментарий "Increment", и эта функция будет вызываться для таких сообщений.
    receive("Increment") {
        self.counter += 1;
    }
}
```

## Функции получения

Функции получения определяют геттеры в смарт-контрактах и ​​могут быть определены только в контракте или признаке.
Функции получения нельзя использовать для чтения состояния другого контракта: если вам нужно получить какие-то данные, вам нужно сделать это, отправив сообщение с запросом и определив получателя, который обработает ответ на запрос.

```tact
contract Treasure {
    get fun counter(): Int {
        return self.counter;
    }
}
```

### Явное разрешение коллизий идентификаторов методов

<Badge text="Доступно с Tact 1.6 (еще не выпущено)" option="tip" size="medium"/><p/>

Как и другие функции в контрактах TVM, геттеры имеют свои _уникальные_ связанные селекторы функций, которые представляют собой некоторые целочисленные идентификаторы (называемые _идентификаторами методов_).
Некоторые из этих целых чисел зарезервированы для внутренних целей, например, -4, -3, -2, -1, 0 являются зарезервированными идентификаторами, а обычные функции (внутренние по отношению к контракту и не вызываемые извне) обычно нумеруются последовательными (небольшими) целыми числами, начиная с 1.
По умолчанию геттеры имеют связанные идентификаторы методов, которые выводятся из их имен с использованием алгоритма [CRC16](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) следующим образом:
`crc16(<function_name>) & 0xffff) | 0x10000`.
Иногда это может привести к тому, что вы получите один и тот же идентификатор метода для получателей с разными именами.
Если это произойдет, вы можете либо переименовать некоторые геттеры контракта, либо указать идентификатор метода геттера вручную как выражение времени компиляции, например так:

```tact
contract ManualMethodId {
    const methodId: Int = 16384 + 42;

    get(self.methodId) fun methodId1(): Int {
        return self.methodId;
    }

    get(crc32("crc32") + 42 & 0x3ffff | 0x4000)
    fun methodId2(): Int {
        return 0;
    }
}
```

Обратите внимание, что вы _не можете_ использовать идентификаторы методов, зарезервированные TVM, и вы не можете использовать некоторые начальные положительные целые числа, поскольку они будут использоваться компилятором в качестве селекторов функций.

Указанные пользователем идентификаторы методов представляют собой 19-битные целые числа со знаком, поэтому можно использовать целые числа от $-2^{18}$ до $-5$ и от $2^{14}$ до $2^{18} - 1$.

Кроме того, несколько идентификаторов методов зарезервированы для использования геттерами, которые компилятор Tact может вставить во время компиляции, это 113617, 115390, 121275.
