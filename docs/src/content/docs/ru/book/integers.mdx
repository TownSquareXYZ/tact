---
title: Целые числа
description: Арифметика в смарт-контрактах на TON всегда выполняется с целыми числами и никогда с числами с плавающей точкой
---

import { Badge } from '@astrojs/starlight/components';

Арифметика в смарт-контрактах на TON всегда выполняется с целыми числами и никогда с числами с плавающей точкой, поскольку числа с плавающей точкой [непредсказуемы](https://learn.microsoft.com/en-us/cpp/build/why-floating-point-numbers-may-lose-precision). Поэтому основной акцент делается на целые числа и их обработку.

Единственный примитивный тип чисел в Tact — `Int{:tact}`, для $257$-битных целых чисел со знаком.\
Он способен хранить целые числа от $-2^{256}$ до $2^{256} - 1.$

## Обозначения

Tact поддерживает различные способы записи примитивных значений `Int{:tact}` как [целочисленных литералов](/ru/book/expressions#integer-literals).

Большинство обозначений позволяют добавлять символы подчеркивания (`_`) между цифрами, за исключением:

- Представлений в строках, как показано в случае [nano-tons](#nanotoncoin).
- Десятичных чисел, записанных с начальным нулем $0.$ Их использование, как правило, не рекомендуется, см. [ниже](#decimal).

Два подряд идущих символа подчеркивания, такие как $4\_\_2$, или символы подчеркивания в конце строки, такие как $42\_$, **не** допускаются.

### Десятичная запись {#decimal}

Наиболее распространенный и используемый способ представления чисел с использованием [десятичной системы счисления](https://en.wikipedia.org/wiki/Decimal): $123456789.$\
Вы можете использовать подчеркивания (`_`) для улучшения читабельности: $123\_456\_789$ равно $123456789.$

:::caution
  В качестве альтернативы вы можете добавить к числу один префикс $0$, что запрещает использование подчеркиваний и допускает только десятичные цифры: $0123 = 123.$
Обратите внимание, что использование этой нотации с ведущим нулем **настоятельно не рекомендуется** из-за возможной путаницы с восьмеричными целыми литералами в TypeScript, который часто используется вместе с Tact для разработки и тестирования контрактов.
:::

### Шестнадцатеричная запись {#hexadecimal}

Представьте числа, используя [шестнадцатеричную систему счисления](https://en.wikipedia.org/wiki/Hexadecimal), обозначаемую префиксом $\mathrm{0x}$ (или $\mathrm{0X}$): $\mathrm{0xFFFFFFFFF}.$\
Используйте подчеркивания (`_`) для улучшения читабельности: $\mathrm{0xFFF\_FFF\_FFF}$ равно $\mathrm{0xFFFFFFFFF}.$

### Восьмеричная запись {#octal}

Представьте числа, используя [восьмеричную систему счисления](https://en.wikipedia.org/wiki/Octal), обозначаемую префиксом $\mathrm{0o}$ (или $\mathrm{0O}$): $\mathrm{0o777777777.}$\
Используйте подчеркивания (`_`) для улучшения читабельности: $\mathrm{0o777\_777\_777}$ равно $\mathrm{0o777777777}.$

### Двоичная запись {#binary}

Представьте числа с помощью [двоичной системы счисления](https://en.wikipedia.org/wiki/Binary_number), обозначенной префиксом $\mathrm{0b}$ (или $\mathrm{0B}$): $\mathrm{0b111111111.}$\
Используйте подчеркивания (`_`) для улучшения читабельности: $\mathrm{0b111\_111\_111}$ равно $\mathrm{0b111111111}.$

### NanoToncoin

Для арифметики с долларами требует два десятичных знака после точки — они используются для обозначения центов. Но как бы мы представили число \$$1.25$, если мы можем работать только с целыми числами? Решение состоит в том, чтобы работать с _центами_ напрямую. Таким образом, \$$1.25$ становится $125$ центами. Мы просто запоминаем, что две крайние правые цифры представляют числа после десятичной точки.

Аналогично, работа с Toncoin, основной валютой блокчейна TON, требует девять десятичных знаков вместо двух. Можно сказать, что nanoToncoin — это $\frac{1}{10^{9}}\mathrm{th}$ Toncoin.

Следовательно, сумма $1.25$ Toncoin, которая может быть представлена ​​в Tact как [`ton("1.25"){:tact}`](/ru/ref/core-comptime#ton), на самом деле является числом $1250000000$. Мы называем такие числа _nanoToncoin(s)_ (или _nano-ton(s)_), а не _cents_.

## Сериализация {#serialization}

При кодировании значений `Int{:tact}` в постоянное состояние (поля [контрактов](/ru/book/contracts) и [признаков](/ru/book/types#traits)), обычно лучше использовать меньшие представления, чем $257$-бит, чтобы снизить [стоимость хранения](https://docs.ton.org/develop/smart-contracts/fees#storage-fee). Использование таких представлений также называется "сериализацией", поскольку они представляют собственные типы [TL-B][tlb], с которыми работает блокчейн TON.

Размер постоянного состояния указывается в каждом объявлении переменной состояния после ключевого слова `as{:tact}`:

```tact
contract SerializationExample {
    // постоянные переменные состояния
    oneByte: Int as int8 = 0; // ranges from -128 to 127 (takes 8 bit = 1 byte)
    twoBytes: Int as int16;   // ranges from -32,768 to 32,767 (takes 16 bit = 2 bytes)

    init() {
        // необходимо инициализировать в init(), поскольку у него нет значения по умолчанию
        self.twoBytes = 55*55;
    }
}
```

Целочисленная сериализация также доступна для полей [структур](/ru/book/structs-and-messages#structs) и [сообщений](/ru/book/structs-and-messages#messages), а также в типах ключ/значение [карты](/ru/book/maps):

```tact
struct StSerialization {
    martin: Int as int8;
}

message MsgSerialization {
    seamus: Int as int8;
    mcFly: map<Int as int8, Int as int8>;
}
```

Основная причина состоит в следующем:

- Хранение 1000 257-битных целых чисел в стейте, [стоит](https://docs.ton.org/develop/smart-contracts/fees#how-to-calculate-fees) около 0,184 TON в год.
- Для сравнения, хранение 1000 32-разрядных целых чисел обходится всего в 0,023 TON в год.

### Распространенные типы сериализации {#common-serialization-types}

|  Имя              | [TL-B][tlb]                 | Включенный диапазон             |                   Занятое пространство                  |
| :---------------: | :-------------------------: | :-----------------------------: | :-----------------------------------------------------: |
|  `uint8{:tact}`   | [`uint8`][tlb-builtin]      |  от $0$ до $2^{8} - 1$          |                    $8$ бит = $1$ байт                   |
|  `uint16{:tact}`  | [`uint16`][tlb-builtin]     |  от $0$ до $2^{16} - 1$         |                   $16$ бит = $2$ байт                   |
|  `uint32{:tact}`  | [`uint32`][tlb-builtin]     |  от $0$ до $2^{32} - 1$         |                   $32$ бит = $4$ байт                   |
|  `uint64{:tact}`  | [`uint64`][tlb-builtin]     |  от $0$ до $2^{64} - 1$         |                   $64$ бит = $8$ байт                   |
|  `uint128{:tact}` | [`uint128`][tlb-builtin]    |  от $0$ до $2^{128} - 1$        |                  $128$ бит = $16$ байт                  |
|  `uint256{:tact}` | [`uint256`][tlb-builtin]    |  от $0$ до $2^{256} - 1$        |                  $256$ бит = $32$ байт                  |
|  `int8{:tact}`    | [`int8`][tlb-builtin]       |  от $-2^{7}$ до $2^{7} - 1$     |                    $8$ бит = $1$ бай                    |
|  `int16{:tact}`   | [`int16`][tlb-builtin]      |  от $-2^{15}$ до $2^{15} - 1$   |                   $16$ бит = $2$ байт                   |
|  `int32{:tact}`   | [`int32`][tlb-builtin]      |  от $-2^{31}$ до $2^{31} - 1$   |                   $32$ бит = $4$ байт                   |
| `int64{:tact}`.   | [`int64`][tlb-builtin]      |  от $-2^{63}$ до $2^{63} - 1$   |                   $64$ бит = $8$ байт                   |
|  `int128{:tact}`  | [`int128`][tlb-builtin]     |  от $-2^{127}$ до $2^{127} - 1$ |                  $128$ бит = $16$ байт                  |
|  `int256{:tact}`  | [`int256`][tlb-builtin]     |  от $-2^{255}$ до $2^{255} - 1$ |                  $256$ бит = $32$ байт                  |
|  `int257{:tact}`  | [`int257`][tlb-builtin]     |  от $-2^{256}$ до $2^{256} - 1$ |             $257$ бит = $32$ байт + $1$ бит             |
|  `coins{:tact}`   | [`VarUInteger 16`][varuint] |  от $0$ до $2^{120} - 1$        | между $4$ и $124$ бит, [см. ниже](#serialization-coins) |

### Произвольные типы разрядности

<Badge text="Доступно с Tact 1.5" option="tip" size="medium"/><p/>

В дополнение к [общим типам сериализации](#common-serialization-types) можно указать произвольные целые числа битовой ширины, используя префикс `int` или `uint`, за которым следуют цифры. Например, запись `int7{:tact}` относится к целому числу со знаком $7$-разрядов.

Минимально допустимая разрядность типа `Int{:tact}` равна $1$, в то время как максимальная составляет $257$ для префиксов `int` (целых чисел со знаком) и $256$ для префиксов `uint` (целых чисел без знака).

|  Имя             | [TL-B][tlb]            | Включенный диапазон                 |             Занятое пространство             |
| :--------------: | :--------------------: | :---------------------------------: | :------------------------------------------: |
| `uintX{:tact}`   | [`uintX`][tlb-builtin] |  от $0$ до $2^{X} - 1$              | $X$ бит, где $X$ находится между $1$ и $256$ |
| `intX{:tact}`    | [`intX`][tlb-builtin]  |  от $-2^{X - 1}$ до $2^{X - 1} - 1$ | $X$ бит, где $X$ находится между $1$ и $257$ |

### Тип переменной `coins` {#serialization-coins}

В Tact `coins{:tact}` является псевдонимом для [`VarUInteger 16`][varuint] в представлении [TL-B][tlb], т. е. она принимает переменную длину в битах в зависимости от оптимального количества байтов, необходимых для хранения данного целого числа, и обычно используется для хранения сумм [nanoToncoin](/ru/book/integers#nanotoncoin).

Этот формат сериализации состоит из двух [полей TL-B](https://docs.ton.org/develop/data-formats/tl-b-language#field-definitions):

- `len`, $4$-битное беззнаковое целое с обратным порядком байтов, хранящее длину байта предоставленного значения
- `value`, 8-битное беззнаковое представление значения в порядке возрастания с обратным порядком байтов

То есть целые числа, сериализованные как `coins{:tact}`, занимают от $4$ до $124$ бит ($4$ бит для `len` и от $0$ до $15$ байт для `value`) и имеют значения в диапазоне от $0$ до $2^{120} - 1$ включительно.

Примеры:

```tact
struct Scrooge {
    // len: 0000, 4 бита (всегда)
    // value: none!
    // всего: 4 бита
    a: Int as coins = 0; // 0000

    // len: 0001, 4 бита
    // value: 00000001, 8 бит
    // всего: 12 бит
    b: Int as coins = 1; // 0001 00000001

    // len: 0010, 4 бита
    // value: 00000001 00000010, 16 бит
    // всего: 20 бит
    c: Int as coins = 258; // 0010 00000001 00000010

    // len: 1111, 4 бита
    // value: двести двадцать единиц в двоичном виде
    // всего: 124 бит
    d: Int as coins = pow(2, 120) - 1; // двести двадцать единиц в двоичной форме
}
```

:::note

  Подробнее о сериализации читайте здесь: [Совместимость с FunC](/ru/book/func#convert-serialization)

:::

## Операции

Все вычисления с числами выполняются на уровне 257 бит, поэтому [переполнения](https://en.wikipedia.org/wiki/Integer_overflow) случаются довольно редко. Тем не менее, если какая-либо математическая операция переполняется, будет выдано исключение, и транзакция завершится ошибкой. Можно сказать, что математика Tact по умолчанию безопасна.

Обратите внимание, что нет никаких проблем со смешиванием переменных [разных размеров состояний](#serialization) в одном вычислении. В среде выполнения они все имеют один и тот же тип — $257$-битное число, поэтому переполнения не возникают.

Однако это все еще может привести к **ошибкам** в [фазе вычисления](https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase) транзакции. Рассмотрим следующий пример:

```tact
import "@stdlib/deploy";

contract ComputeErrorsOhNo with Deployable {
    oneByte: Int as uint8; // переменная состояния, максимальное значение — 255
    init() {
        self.oneByte = 255; // начальное значение — 255, все в порядке
    }

    receive("lets break it") {
        let tmp: Int = self.oneByte * 256; // нет переполнения во время выполнения
        self.oneByte = tmp; // упс, значение tmp выходит за пределы ожидаемого диапазона oneByte    }
}
```

Здесь `oneByte` сериализуется как [`uint8`](#common-serialization-types), который занимает всего один байт и находится в диапазоне от $0$ до $2^{8} - 1$, что составляет $255$. И при использовании в вычислениях во время выполнения переполнения не происходит, и все вычисляется как $257$-битные целые числа со знаком. Но в тот самый момент, когда мы решаем сохранить значение `tmp` обратно в `oneByte`, мы получаем ошибку с [exit code 5](/ru/book/exit-codes#5), которая гласит следующее: `Целое число выходит за пределы ожидаемого диапазона`.

:::caution
  Поэтому будьте **очень** осторожны с числами и всегда дважды проверяйте вычисления при использовании сериализации.
:::

[tlb]: https://docs.ton.org/develop/data-formats/tl-b-language
[tlb-builtin]: https://docs.ton.org/develop/data-formats/tl-b-language#built-in-types
[varuint]: https://docs.ton.org/develop/data-formats/msg-tlb#varuinteger-n
