---
title: Карты
description: Карта составного типа используется как способ связать ключи с соответствующими значениями различных типов
---

import { Badge } from '@astrojs/starlight/components';

[Составной тип](/ru/book/types#composite-types) `map<K, V>{:tact}` используется как способ связать ключи типа `K{:tact}` с соответствующими значениями типа `V{:tact}`.

Например, `map<Int, Int>{:tact}` использует тип [`Int{:tact}`][int] для своих ключей и значений:

```tact
struct IntToInt {
    counters: map<Int, Int>;
}
```

## Допустимые типы {#allowed-types}

Допустимые типы ключей:

- [`Int{:tact}`][int]
- [`Address{:tact}`][p]

Допустимые типы значений:

- [`Int{:tact}`][int]
- [`Bool{:tact}`](/ru/book/types#booleans)
- [`Cell{:tact}`][cell]
- [`Address{:tact}`][p]
- [Структура](/ru/book/structs-and-messages#structs)
- [Сообщение](/ru/book/structs-and-messages#messages)

## Сериализация

Можно выполнить [целочисленную сериализацию](/ru/book/integers#common-serialization-types) ключей карты, значений или и того, и другого, чтобы [сохранить место и сократить затраты на хранение](/ru/book/integers#serialization):

```tact
struct SerializedMapInside {
    // И ключи, и значения здесь будут сериализованы как 8-битные беззнаковые целые числа,
    // таким образом сохраняя пространство и сокращая затраты на хранение:
    countersButCompact: map<Int as uint8, Int as uint8>;
}
```

:::note

  Подробнее о сериализации читайте в Tact: [Совместимость с FunC](/ru/book/func#convert-serialization).

:::

## Операции

### Объявляем `emptyMap()` {#emptymap}

Как [локальную переменную](/ru/book/statements#let), используя функцию `emptyMap(){:tact}` стандартной библиотеки:

```tact
let fizz: map<Int, Int> = emptyMap();
let fizz: map<Int, Int> = null; // аналогично предыдущей строке, но менее описательно
```

Как [переменная постоянного состояния](/ru/book/contracts#variables):

```tact
contract Example {
    fizz: map<Int, Int>; // Int keys to Int values
    init() {
        self.fizz = emptyMap(); // избыточно и может быть удалено!
    }
}
```

Обратите внимание, что [переменные постоянного состояния](/ru/book/contracts#variables) типа `map<K, V>{:tact}` по умолчанию инициализируются пустыми и не требуют явных значений или инициализации в функции [`init(){:tact}`](/ru/book/contracts#init-function).

### Установка значений, `.set()` {#set}

```tact
// K и V соответствуют типам ключа и значения данной карты
extends mutates fun set(self: map<K, V>, key: K, val: V);
```

Чтобы установить или заменить значение в соответствии с ключом, вызовите [метод](/ru/book/functions#extension-function) `.set(){:tact}`, который доступен для всех карт.

```tact
// Пустая карта
let fizz: map<Int, Int> = emptyMap();

// Установка нескольких значений под разными ключами
fizz.set(7, 7);
fizz.set(42, 42);

// Переопределение одной из существующих пар ключ-значение
fizz.set(7, 68); // key 7 now points to value 68
```

### Получаем значения, `.get()` {#get}

```tact
// K и V соответствуют типам ключа и значения данной карты
extends fun get(self: map<K, V>, key: K): V?;
```

Чтобы проверить, найден ли ключ в карте, вызовите [метод](/ru/book/functions#extension-function) `.get(){:tact}`, который доступен для всех карт. Это вернет [`null{:tact}`](/ru/book/optionals), если ключ отсутствует, или значение, если ключ найден.

```tact
// Пустая карта
let fizz: map<Int, Int> = emptyMap();

// Установка значения
fizz.set(68, 0);

// Получение значения по его ключу
let gotButUnsure: Int? = fizz.get(68);          // возвращает значение Int или null, следовательно, тип является Int?
let mustHaveGotOrErrored: Int = fizz.get(68)!!; // явно указывает, что значение не должно быть null,
                                                // который может сработать во время выполнения, если значение на самом деле равно null

// В качестве альтернативы мы можем проверить наличие ключа в операторе if
if (gotButUnsure != null) {
    // Ура, давайте теперь без страха использовать !! и привести Int? к Int
    let definitelyGotIt: Int = fizz.get(68)!!;
} else {
    // Сделаем что-нибудь еще...
}
```

### Замена значений `.replace()` {#replace}

<Badge text="Доступно с версии Tact 1.6 (еще не выпущено)" option="tip" size="medium"/><p/>

```tact
// K и V соответствуют типам ключа и значения данной карты
extends mutates fun replace(self: map<K, V>, key: K, val: V): Bool;
```

Чтобы заменить значение под ключом, если такой ключ существует, используйте [метод](/ru/book/functions#extension-function). `.replace(){:tact}`. Этот метод возвращает `true{:tact}` при успешной замене и `false{:tact}`, если замена не удалась.

```tact
// Пустая карта
let fizz: map<Int, Int> = emptyMap();

// Установка пары значений под разными ключами
fizz.set(7, 70);
fizz.set(42, 42);

// Переопределение одной из существующих пар ключ-значение
let replaced1 = fizz.replace(7, 68); // ключ 7 теперь указывает на значение 68
replaced1; // true

// Попытка заменить значение в несуществующей паре ключ-значение ничего не даст
let replaced2 = fizz.replace(8, 68); // ключа 8 нет, поэтому ничего не было изменено
replaced2; // false
```

Если заданное значение равно [`null{:tact}`](/ru/book/optionals) и ключ существует, запись будет удалена из карты.

```tact
// Пустая карта
let fizz: map<Int, Int> = emptyMap();

// Установка пары значений под разными ключами
fizz.set(7, 70);
fizz.set(42, 42);

// Переопределение одной из существующих пар ключ-значение
let replaced1 = fizz.replace(7, null); // запись под ключом 7 теперь удалена
replaced1; // true

// Попытка заменить значение в несуществующей паре ключ-значение ничего не даст
let replaced2 = fizz.replace(8, null); // ключа 8 нет, поэтому ничего не было изменено
replaced2; // false
```

### Замена и получение старого значения, `.replaceGet()` {#replaceget}

<Badge text="Доступно с версии Tact 1.6 (еще не выпущено)" option="tip" size="medium"/><p/>

```tact
// K и V соответствуют типам ключа и значения данной карты
extends mutates fun replaceGet(self: map<K, V>, key: K, val: V): V?;
```

Как и [`.replace()`](#replace), но вместо того, чтобы возвращать [`Bool{:tact}`](/ru/book/types#booleans), он возвращает старое значение (до замены) при успешной замене и [`null{:tact}`](/ru/book/optionals), если замена не удалась.

```tact
// Пустая карта
let fizz: map<Int, Int> = emptyMap();

// Установка пары значений под разными ключами
fizz.set(7, 70);
fizz.set(42, 42);

// Переопределение одной из существующих пар ключ-значение
let oldVal1 = fizz.replaceGet(7, 68); // ключ 7 теперь указывает на значение 68
oldVal1; // 70

// ключ 7 теперь указывает на значение 68
let oldVal2 = fizz.replaceGet(8, 68); // нет ключа 8, поэтому ничего не было изменено
oldVal2; // null
```

Если заданное значение равно [`null{:tact}`](/ru/book/optionals) и ключ существует, запись будет удалена из карты.

```tact
// Пустая карта
let fizz: map<Int, Int> = emptyMap();

// Установка нескольких значений под разными ключами
fizz.set(7, 70);
fizz.set(42, 42);

// Переопределение одной из существующих пар ключ-значение
let oldVal1 = fizz.replaceGet(7, null); // запись под ключом 7 теперь удалена
oldVal1; // 70

// Попытка заменить значение в несуществующей паре ключ-значение ничего не даст
let oldVal2 = fizz.replaceGet(8, null); // нет ключа 8, поэтому ничего не было изменено
oldVal2; // null
```

### Удаление записей, `.del()` {#del}

```tact
// K и V соответствуют типам ключа и значения данной карты
extends mutates fun del(self: map<K, V>, key: K): Bool;
```

Чтобы удалить одну пару ключ-значение (одну запись), используйте [метод](/ru/book/functions#extension-function) `.del(){:tact}`. Он возвращает `true{:tact}`, если запись была успешно удалена, и `false{:tact}`, если не было ничего изменено.

```tact
// Пустая карта
let fizz: map<Int, Int> = emptyMap();

// Установка пары значений под разными ключами
fizz.set(7, 123);
fizz.set(42, 321);

// Удаление одного из ключей
let deletionSuccess: Bool = fizz.del(7); // true, потому что карта содержала запись под ключом 7
fizz.del(7);                             // false, потому что карта больше не имеет записи под ключом 7

// Обратите внимание, что присвоение значения `null` ключу при использовании метода `.set()`
//   эквивалентно вызову `.del()`, хотя такой подход гораздо менее описателен
//   и, как правило, не рекомендуется:
fizz.set(42, null); // запись под ключом 42 теперь удалена
```

Чтобы удалить все записи из карты, переопределите ее с помощью функции `emptyMap(){:tact}`:

```tact
// Пустая карта
let fizz: map<Int, Int> = emptyMap();

// Установка нескольких значений под разными ключами
fizz.set(7, 123);
fizz.set(42, 321);

// даление всех записей сразу
fizz = emptyMap();
fizz = null; // аналогично предыдущей строке, но менее описательно
```

При таком подходе все предыдущие записи карты полностью удаляются из контракта, даже если карта была объявлена ​​как ее постоянное состояние переменной. В результате назначение карт `emptyMap(){:tact}` **не** вызывает никаких скрытых или внезапных [плат за хранение](https://docs.ton.org/develop/smart-contracts/fees#storage-fee).

### Проверка существования записи, `.exists()` {#exists}

<Badge text="Доступно с Tact 1.5" option="tip" size="medium"/><p/>

```tact
// K и V соответствуют типам ключа и значения данной карты
extends fun exist(self: map<K, V>, key: K): Bool;
```

[Метод](/ru/book/functions#extension-function) `.exists(){:tact}` на картах возвращает `true{:tact}`, если значение под указанным ключом существует на карте, и `false{:tact}`, если нет.

```tact
let fizz: map<Int, Int> = emptyMap();
fizz.set(0, 0);

if (fizz.exists(2 + 2)) { // false
    dump("Что-то не так!");
}

if (fizz.exists(1 / 2)) { // true
    dump("Я когда-то шутку о дроби рассказывал. Она была наполовину забавной.");
}

if (fizz.get(1 / 2) != null) { // также true, но расходует больше газа
    dump("Нужно заправить ещё!");
}
```

:::note

  Вызов `m.exists(key){:tact}` более экономичен, чем выполнение `m.get(key) != null{:tact}`, хотя оба подхода дают одинаковые результаты.

:::

### Проверка на пустоту, `.isEmpty()` {#isempty}

```tact
// K и V соответствуют типам ключа и значения данной карты
extends fun isEmpty(self: map<K, V>): Bool;
```

[Метод](/ru/book/functions#extension-function) `.isEmpty(){:tact}` для карт возвращает `true{:tact}`, если карта пуста, и `false{:tact}` в противном случае:

```tact
let fizz: map<Int, Int> = emptyMap();

if (fizz.isEmpty()) {
    dump("Пустые мапы - пусты, значит, понятно!");
}

// Обратите внимание, что сравнение карты с `null` ведет себя так же, как метод `.isEmpty()`,
// хотя такое прямое сравнение гораздо менее наглядно и обычно не рекомендуется:
if (fizz == null) {
    dump("Пустые карты пусты, что неочевидно");
}
```

### Сравнение с `.deepEquals()` {#deepequals}

<Badge text="Доступно с Tact 1.5" variant="tip" size="medium"/><p/>

```tact
// K и V соответствуют типам ключа и значения данной карты
extends fun deepEquals(self: map<K, V>, other: map<K, V>): Bool;
```

[Метод](/ru/book/functions#extension-function) `.deepEquals(){:tact}` на картах возвращает `true{:tact}`, если все записи карты совпадают с соответствующими записями другой карты, игнорируя возможные различия в [базовой логике сериализации][hashmap]. В противном случае возвращает `false{:tact}`.

```tact
let fizz: map<Int, Int> = emptyMap();
let buzz: map<Int, Int> = emptyMap();

fizz.set(1, 2);
buzz.set(1, 2);

fizz.deepEquals(buzz); // true
fizz == buzz;          // rue, и использует гораздо меньше газа для вычисления
```

Использование `.deepEquals(){:tact}` очень важно в случаях, когда карта поступает из стороннего источника, который не дает никаких гарантий относительно [схемы сериализации][hashmap]. В качестве одного из таких примеров рассмотрим следующий код:

```typescript title="some-typescript-code.ts"
// Первая карта с длинными метками
const m1 = beginCell()
    .storeUint(2, 2) // длинная метка
    .storeUint(8, 4) // длина ключа
    .storeUint(1, 8) // ключ
    .storeBit(true)  // значение
    .endCell();

// Вторая карта с короткими метками
const m2 = beginCell()
    .storeUint(0, 1)           // короткая метка
    .storeUint(0b111111110, 9) // длина ключа
    .storeUint(1, 8)           // ключ
    .storeBit(true)            // значение
    .endCell();
```

В этом примере обе карты формируются вручную и содержат одинаковую пару ключ-значение. Если бы вы отправили обе эти карты в сообщении в контракт Tact, а затем сравнили их с `.deepEquals(){:tact}` и [оператором равенства `=={:tact}`](/ru/book/operators#binary-equality), первая выдала бы `true{:tact}`, потому что обе карты имеют одинаковую запись, тогда как вторая выдала бы `false{:tact}`, потому что она выполняет только поверхностное сравнение хэшей карт. И они отличаются, поскольку карты сериализуются по-разному.

:::note

  Эта функция очень затратна на газ, и в большинстве случаев будет достаточно использовать поверхностное сравнение с помощью операторов [равенство `=={:tact}`](/ru/book/operators#binary-equality) или [неравенство `!={:tact}`](/ru/book/operators#binary-equality).

:::

### Преобразование в `Cell`, `.asCell()` {#ascell}

```tact
// K и V соответствуют типам ключа и значения данной карты
extends fun asCell(self: map<K, V>): Cell;
```

В [TVM][tvm] карты представлены как тип [`Cell{:tact}`][cell], и их можно создавать и анализировать напрямую. Однако такой подход весьма подвержен ошибкам и довольно запутан, поэтому Tact предоставляет карты как отдельный составной тип со многими вспомогательными методами, упомянутыми выше.

Чтобы преобразовать карты обратно в базовый тип [`Cell{:tact}`][cell], используйте [метод] `.asCell(){:tact}` (/book/functions#extension-function). Поскольку карты инициализируются значением `null{:tact}`, вызов `.asCell(){:tact}` для карты без назначенных значений вернет `null{:tact}`, а **не** пустую [`Cell{:tact}`][cell].

Например, этот метод полезен для отправки небольших карт непосредственно в теле ответа:

```tact
contract Example {
    // Постоянные состояния переменных
    fizz: map<Int, Int>; // our map

    // Функция конструктора (инициализации) контракта
    init() {
        // Setting a bunch of values
        self.fizz.set(0, 3);
        self.fizz.set(1, 14);
        self.fizz.set(2, 15);
        self.fizz.set(3, 926);
        self.fizz.set(4, 5_358_979_323_846);
    }

    // Внутренний приемник сообщений, который отвечает на пустые сообщения
    receive() {
        // Здесь мы преобразуем карту в ячейку и делаем ответ с ее помощью
        self.reply(self.fizz.asCell()!!); // явно утверждаем, что карта не является нулевой
    }
}
```

### Перебор записе {#traverse}

Чтобы перебирать записи в карте используется оператор цикла [`foreach{:tact}`](/ru/book/statements#foreach-loop):

```tact
// Пустая карта
let fizz: map<Int, Int> = emptyMap();

// Установка пары значений под разными ключами
fizz.set(42, 321);
fizz.set(7, 123);

// Итерация в последовательном порядке: от наименьших ключей к наибольшим
foreach (key, value in fizz) {
    dump(key); // выведет 7 на первой итерации, затем 42 на второй
}
```

Подробнее об этом: [цикл `foreach{:tact}` в Книге→Утверждения](/ru/book/statements#foreach-loop).

Обратите внимание, что карты также можно использовать как простые массивы, если определить `map<Int, V>{:tact}` с типом [`Int{:tact}`][int] для ключей, любым допустимым типом `V{:tact}` для значений и отслеживать количество элементов в отдельной переменной:

```tact
contract Iteration {
    // Постоянные состояния переменных
    counter: Int as uint32;    // счётчик записей в карте, серилизованная как 32-битное беззнаковое число
    record: map<Int, Address>; // Карта Int в адрес

    // Функция конструктора (инициализации) контракта
    init() {
        self.counter = 0; // Установка self.counter на 0    }

    // Внутренний метод для приема сообщений, который отвечает на строковое сообщение "Add"
    receive("Add") {
        // Получить структуру контекста
        let ctx: Context = context();
        // Задать запись: counter Int как ключ, ctx.sender Address как значение
        self.record.set(self.counter, ctx.sender);
        // Увеличить счетчик
        self.counter += 1;
    }

    // Внутренний метод для приема сообщений, который отвечает на строковое сообщение "Get"
    receive("Send") {
        // Цикл до значения self.counter (по всем записям self.record)
        let i: Int = 0; // объявляем обычный i для итераций цикла
        while (i < self.counter) {
           send(SendParameters{
                bounce: false,              // не возвращать это сообщение
                to: self.record.get(i)!!,   // устанавливаем адрес отправителя, зная, что ключ i существует в карте
                value: ton("0.0000001"),    // 100 nanoToncoins (nano-tons)
                mode: SendIgnoreErrors,     // отправляем, игнорируя ошибки в транзакции, если таковые имеются
                body: "SENDING".asComment() // Строка "SENDING" преобразуется в ячейку как тело сообщения
            });
            i += 1; // не забудьте увеличить i
        }
    }

    // Метод для получения значения self.record
    get fun map(): map<Int, Address> {
        return self.record;
    }

    // Метод для получения значения self.counter
    get fun counter(): Int {
        return self.counter;
    }
}
```

Иногда полезно устанавливать верхнюю границу для таких карт, [чтобы избежать ограничений](#limits-and-drawbacks).

:::caution

  Обратите внимание, что ручное отслеживание количества элементов или проверка длины такой карты очень подвержены ошибкам и, как правило, не рекомендуются. Вместо этого попробуйте обернуть вашу карту в [структуру](/ru/book/structs-and-messages#structs) и определить [функции расширения](/ru/book/functions#extension-function) для нее. Смотрите пример в кулинарной книге: [Как эмулировать массив, используя карту, заключенную в структуру](/ru/cookbook/data-structures#array).

:::

:::note

  Этот пример был адаптирован из [howardpen9/while-example-tact](https://github.com/howardpen9/while-example-tact/blob/de5807fcd20dba5f6a3748d112511477fb22bfcc/contracts/awesome.tact#L19C10-L19C10).

  Смотрите другие примеры использования карты в кулинарной книге:\
  [Как эмулировать стек, используя карту, заключенную в структуру](/ru/cookbook/data-structures#stack)\
  [Как эмулировать циклический буфер, используя карту, заключенную в структуру](/ru/cookbook/data-structures#circular-buffer)

:::

## Ограничения и минусы {#limits-and-drawbacks}

Хотя карты могут быть удобны для работы в небольших масштабах, они вызывают ряд проблем, если количество элементов не ограничено, а размер карты может значительно увеличиваться:

- Поскольку верхняя граница размера состояния смарт-контракта составляет около $65\,000$ элементов типа [`Cell{:tact}`][cell], это ограничивает лимит хранения карт до $30\,000$ пар ключ-значение для всего контракта.

- Чем больше записей у вас на карте, тем больше [плату за вычисления](https://docs.ton.org/develop/howto/fees-low-level#computation-fees) вы получите. Таким образом, при работе с большими картами стоимость вычислений сложно прогнозировать и управлять ими.

- Использование большой карты в одном контракте не позволяет распределить ее рабочую нагрузку. Следовательно, это может значительно ухудшить общую производительность по сравнению с использованием меньшей карты и множества взаимодействующих смарт-контрактов.

Чтобы решить такие проблемы, вы можете установить ограничение верхней границы для карты как константу и проверять его каждый раз, когда вы устанавливаете новое значение для карты:

```tact
contract Example {
    // Объявляем верхнюю границу константы времени компиляции для нашей карты
    const MaxMapSize: Int = 42;

    // Постоянные состояния переменных 
    arr: map<Int, Int>; // "массив" значений Int как карта
    arrLength: Int = 0; // лина "массива", по умолчанию 0

    // Внутренняя функция для помещения элемента в конец "массива"
    fun arrPush(item: Int) {
        if (self.arrLength >= self.MaxMapSize) {
            // Сделать что-нибудь, например остановить операцию
        } else {
            // Продолжить добавление нового элемента
            self.arr.set(self.arrLength, item);
            self.arrLength += 1;
        }
    }
}
```

Если вам все еще нужна большая карта или несвязанная (бесконечно большая) карта, лучше спроектировать свои смарт-контракты в соответствии с [асинхронной и основанной на акторах моделью блокчейна TON](https://docs.ton.org/learn/overviews/ton-blockchain). То есть использовать шардинг контрактов и по сути сделать весь блокчейн частью вашей карты(карт).

{/*
TODO: Добавить ссылку на страницу шардинга согласно: https://github.com/tact-lang/tact-docs/issues/155
*/}

[p]: /ru/book/types#primitive-types
[int]: /ru/book/integers
[клетка]: /ru/book/cells#cells
[hashmap]: https://docs.ton.org/develop/data-formats/tl-b-types#hashmap
[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
