---
title: Операторы
description: На этой странице перечислены все операторы в Tact в порядке убывания их приоритета, с примерами использования
prev:
  link: /book/exit-коды
  label: Exit codes
---

Почти каждый контракт работает с данными: преобразует одни значения в другие. Область применения может варьироваться, но в основе таких изменений лежат операторы.

На этой странице перечислены все операторы Tact в порядке убывания их [приоритета](#precedence), с примерами использования.

:::note

  Обратите внимание, что в Tact нет неявных преобразований типов, поэтому операторы нельзя использовать, например, для сложения значений разных типов или их сравнения по равенству без явного приведения к одному типу. Это делается с помощью определенных функций из стандартной библиотеки. Пример такой функции см. в [`Int.toString(){:tact}`](/ref/core-strings#inttostring).

:::

## Таблица операторов {#table}

В этой таблице операторы перечислены в порядке убывания [приоритета](#precedence): от наивысшего к наименьшему.

| Краткое описание     | Операторы                                                                                       |
| :------------------- | :---------------------------------------------------------------------------------------------- |
| Скобки               | [`(){:tact}`][paren]                                                                            |
| Унарный постфикс     | [`!!{:tact}`][nna]                                                                              |
| Унарный префикс      | [`+{:tact}`][plus] &nbsp; [`-{:tact}`][neg] &nbsp; [`!{:tact}`][inv] &nbsp; [`~{:tact}`][b-not] |
| Мультипликативные    | [`*{:tact}`][mul] &nbsp; [`/{:tact}`][div] &nbsp; [`%{:tact}`][mod]                             |
| Аддитивные           | [`+{:tact}`][add] &nbsp; [`-{:tact}`][sub]                                                      |
| Сдвиг                | [`>>{:tact}`][shr] &nbsp; [`<<{:tact}`][shl]                                                    |
| Реляционные          | [`>{:tact}`][gt] &nbsp; [`>={:tact}`][ge] &nbsp; [`<{:tact}`][lt] &nbsp; [`<={:tact}`][le]      |
| Равенство            | [`=={:tact}`][eq] &nbsp; [`!={:tact}`][eq]                                                      |
| Побитовое AND        | [`&{:tact}`][b-and]                                                                             |
| Побитовое XOR        | [`^{:tact}`][b-xor]                                                                             |
| Побитовое OR         | [`\|{:tact}`][b-or]                                                                             |
| Логическое AND       | [`&&{:tact}`][l-and]                                                                            |
| Логическое OR        | [`\|\|{:tact}`][l-or]                                                                           |
| Тернарный            | [`?:{:tact}`][ternary]                                                                          |
| Присваивание         | [`={:tact}`][assign] и [все расширенные операторы присваивания](#augmented-assignment)          |

[paren]: #parentheses
[nna]: #unary-non-null-assert
[plus]: #unary-plus
[neg]: #unary-negate
[inv]: #unary-inverse
[b-not]: #unary-bitwise-not
[mul]: #binary-multiply
[div]: #binary-divide
[mod]: #binary-modulo
[add]: #binary-add
[sub]: #binary-subtract
[shr]: #binary-bitwise-shift-right
[shl]: #binary-bitwise-shift-left
[gt]: #binary-greater
[ge]: #binary-greater-equal
[lt]: #binary-less
[le]: #binary-less-equal
[eq]: #binary-equality
[b-and]: #binary-bitwise-and
[b-xor]: #binary-bitwise-xor
[b-or]: #binary-bitwise-or
[l-and]: #binary-logical-and
[l-or]: #binary-logical-or
[ternary]: #ternary
[assign]: #assignment

## Приоритет

Все операторы на этой странице представлены в порядке убывания приоритета, от наивысшего к наименьшему. Приоритет используется для выбора оператора, который будет учитываться в конкретной ситуации. При возникновении неоднозначности Tact предпочтет операторы с более высоким приоритетом перед операторами с более низким.

Например, знак минус (`-{:tact}`) может рассматриваться как оператор вычитания или как оператор отрицания, который меняет знак выражения с плюса на минус, или наоборот. Поскольку последний имеет более высокий приоритет по сравнению с первым, в случаях неоднозначности между ними, Tact сначала рассмотрит `-{:tact}` как оператор отрицания. И если это не имеет смысла для данного выражения, только тогда он рассмотрит его как оператор вычитания.

Рассмотрим следующий код:

```tact
5 + -5; // здесь знак минус будет рассматриваться как оператор отрицания
5 -5; // а здесь он будет рассматриваться как оператор вычитания, несмотря на форматирование
```

Несмотря на то, что этот пример может показаться простым, пренебрежение правилами приоритета часто может приводить к путанице с операторами. Правильный порядок операций можно обеспечить, заключив каждую операцию в [круглые скобки](#parentheses), поскольку круглые скобки имеют самый высокий приоритет среди всех выражений и операторов.

## Скобки, `()` {#parentheses}

Скобки (их также могут называться круглыми скобками, `(){:tact}`) - скорее являются знаками препинания, чем реальными операторами, но их [приоритет](#precedence) выше, чем у любого другого оператора. Используйте скобки, чтобы изменить порядок операций:

```tact
5 * 5 - 2;   // 23
5 * (5 - 2); // 15
```

:::note

  Текущий максимально допустимый вложенный уровень выражений $83$. Попытка написать более сложное выражение приведет к ошибке компиляции:

```tact
fun elegantWeaponsForCivilizedAge(): Int {
    return
    ((((((((((((((((((((((((((((((((
        ((((((((((((((((((((((((((((((((
            (((((((((((((((((((( // 84 parens, compilation error!
                42
            ))))))))))))))))))))
        ))))))))))))))))))))))))))))))))
    ))))))))))))))))))))))))))))))));
}
```

:::

## Унарные операторы

Унарные в данном случае означают, что они применяются только к одному операнду в заданном выражении. Все унарные операторы, за исключением утверждения ненулевого значения [(non-null assertion)](#unary-non-null-assert), имеют одинаковый [приоритет](#precedence).

Унарные операторы могут быть одного из двух типов:

- Префикс — ставятся перед выражением.
- Постфикс (или суффикс) — ставятся после выражения.

### Утверждение о ненулевом значении, `!!` {#unary-non-null-assert}

Унарный оператор двойного восклицательного знака (_ненулевое утверждение_) `!!{:tact}` - это постфиксный оператор, который гарантирует значения, отличные от `null{:tact}`, и позволяет напрямую получить доступ к значению опциональной переменной, если она не равна `null{:tact}`. В противном случае вызывает ошибку компиляции, если компилятор может это отследить, или генерирует исключение с [кодом выхода 128](/book/exit-codes#128): `Null reference exception`. Может быть применён к любой опциональной переменной независимо от её типа, отличного от `null{:tact}` типа.

:::note

  Подробнее об опциональных переменных и полях читайте здесь: [Опциональные значения](/book/optionals)

:::

### Плюс, `+` {#unary-plus}

Хотя унарный оператор плюс `+{:tact}` указан в грамматике компилятора Tact, он существует только как [бинарный оператор](#binary-add).

### Отрицание, `-` {#unary-negate}

Унарный оператор со знаком минус (_отрицание_) `-{:tact}` является префиксным оператором, который меняет знак выражения на противоположный. Может применяться только к значениям типа [`Int{:tact}`][int]:

```tact
let five: Int = 5;
five + -five; // здесь знак минус - это оператор отрицания, а не вычитания
-(-1);        // двойное применение возвращает исходное значение, которое равно 1
--1;          // 1
```

### Инверсия, `!` {#unary-inverse}

Унарный оператор с восклицательным знаком (_инверсия_) `!{:tact}` является префиксным оператором, который инвертирует булево значение выражения - меняет `true{:tact}` на `false{:tact}`, и наоборот. Может применяться только к значениям типа [`Bool{:tact}`][bool]:

```tact
let iLikeTact: Bool = true;
!iLikeTact; // false
!false;     // true
!(!false);  // false
!!false;    // false
```

### Побитовое NOT, `~` {#unary-bitwise-not}

Унарный оператор тильда (_побитовое NOT_) `~{:tact}` это префиксный оператор, который инвертирует или _переворачивает_ каждый бит в двоичном представлении выражения, заменяя $1$ на $0$ и наоборот. Может применяться только к значениям типа [`Int{:tact}`][int]:

```tact
let answer: Int = 42;
~answer;    // -43
~(~answer); // 42
~(~0);      // 0
~~0;        // 0
```

## Бинарные операторы

Бинарные операторы разделены на несколько подразделов, в порядке убывания [приоритета](#precedence). Операторы в каждом подразделе имеют такой же [приоритет](#precedence), как и сам подраздел.

### Мультипликативные {#binary-multiplication}

Умножение, разделение или получение остатка.

#### Умножение, `*` {#binary-multiply}

Бинарный оператор звёздочка (_умножение_) `*{:tact}` используется для умножения двух значений. Может вызвать [целочисленное переполнение] (/book/integers#operations).

Может быть применен только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two * two;         // 4
0 * 1_000_000_000; // 0
-1 * 5;            // -5

pow(2, 255) * pow(2, 255); // ошибка сборки: целочисленное переполнение!
```

#### Деление, `/` {#binary-divide}

Бинарный оператор слэш (_деление_) `/{:tact}` используется для целочисленного деления двух значений. Результат округляется в меньшую сторону, если он положительный, и в большую сторону, если он отрицательный. Это также называется [округлением вниз](https://en.wikipedia.org/wiki/Rounding#Rounding_down) (или округлением в сторону $-∞$).

Попытка деления на ноль вызовет ошибку с [кодом выхода 4](/book/exit-codes#4): `Integer overflow`.

Может быть применен только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two / 2; // 1
two / 1; // 2
-1 / 5;  // -1
-1 / -5; // 0
1 / -5;  // -1
1 / 5;   // 0
6 / 5;   // 1, округление вниз
-6 / 5;  // -2, округление вниз (в сторону -∞)
```

:::note

  Следующее соотношение между операторами деления и [по модулю](#binary-modulo) всегда выполняется для типа `Int{:tact}`:

```tact
a / b * b + a % b == a; // true для любых значений Int `a` и `b`,
                        //  за исключением случая, когда `b` равно 0 и происходит деление `a` на 0,
                        //   что является попыткой деления на ноль и приводит к ошибке
```

:::

#### По модулю, `%` {#binary-modulo}

Бинарный оператор процента (_по модулю_) `%{:tact}` используется для получения значения по модулю целочисленного деления, которое не следует путать с получением остатка. Для двух значений с одинаковым знаком операции по модулю и с остатком эквивалентны. Однако, если знаки операндов различаются, результат по модулю всегда имеет тот же знак, что и _делитель_ (значение справа), а остаток имеет тот же знак, что и _делимое_ (значение слева). Это может привести к разнице на одну единицу значения _делителя_.

Может быть применён только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two % 2; // 0
two % 1; // 1

1 % 5;   // 1
-1 % 5;  // 4
1 % -5;  // -4
-1 % -5; // -1
```

Самый простой способ избежать путаницы между по модулю и остатком - это [использовать только беззнаковые целые числа](/book/security-best-practices#misuse-of-signed-integers). В качестве альтернативы можно использовать функцию [`abs(){:tact}`](/ref/core-math#abs) для обеспечения неотрицательных значений:

```tact
abs(-1) % abs(-5); // 1
```

:::note

  Следующее соотношение между операторами [деления](#binary-divide) и по модулю всегда выполняется для типа `Int{:tact}`:

```tact
a / b * b + a % b == a; // true для любых значений Int `a` и `b`,
                        //   за исключением случаев, когда `b` равно 0 и происходит деление `a` на 0,
                        //   что является попыткой деления на ноль и приводит к ошибке
```

:::

:::note

  Знаете ли вы, что в JavaScript `%{:tact}` работает как оператор _остатка_, а не как оператор _по модулю_ (как в Tact)?\
  [Остаток (%) - JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder#description)\
  [По модулю - Wikipedia](https://en.wikipedia.org/wiki/Modulo)

:::

### Сложение {#binary-addition}

Сложение или вычитание.

#### Сложение, `+` {#binary-add}

Бинарный оператор плюс (_сложение_) `+{:tact}` используется для сложения чисел. Превышение максимального значения [`Int{:tact}`][int] приведет к ошибке с [кодом выхода 4](/book/exit-codes#4): `Integer overflow`.

Может применяться только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two + 2; // 4
-1 + 1;  // 0

pow(2, 254) + pow(2, 254);     // 2 * 2^254
pow(2, 255) + pow(2, 255);     // ошибка сборки: переполнение целого числа!
pow(2, 255) - 1 + pow(2, 255); // 2^256 - 1, максимальное значение любого целого числа в Tact!
```

#### Вычитание, `-` {#binary-subtract}

Бинарный оператор минус (_вычитание_) `-{:tact}` используется для вычитания одного числа из другого. Выход за минимальное значение типа [`Int{:tact}`][int] приведет к ошибке с [кодом завершения 4](/book/exit-codes#4): `Integer overflow`.

Может быть применен только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two - 2; // 0
-1 - 1;  // -2

pow(2, 254) - pow(2, 254); // 0
pow(2, 255) - pow(2, 255); // 0
pow(2, 256) - pow(2, 256); // ошибка сборки: переполнение целого числа!
```

### Побитовые сдвиги {#binary-bitwise-shifts}

Сдвиг битов влево или вправо.

#### Сдвиг вправо, `>>` {#binary-bitwise-shift-right}

Бинарный оператор двойного знака "больше" (_побитовый сдвиг вправо_) `>>{:tact}` возвращает целое число, бинарное представление которого является значением _левого операнда_, сдвинутым на количество битов _правого операнда_ вправо. Лишние биты, сдвинутые вправо, отбрасываются, а копии самого левого бита заполняют слева. Эта операция также называется "знаковый сдвиг вправо" или "арифметический сдвиг вправо", так как знак результата совпадает со знаком _левого операнда_. Это более эффективный способ разделить _левый операнд_ на $2^n$, где $n$ равен _правому операнду_.

Может применяться только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two >> 1; // 1
4 >> 1;   // 2
5 >> 1;   // 2, из-за использования целочисленных значений

pow(2, 254) >> 254; // 1
```

:::note

  [Битовые сдвиги - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts)\
  [Манипулирование битами - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

#### Сдвиг влево, `<<` {#binary-bitwise-shift-left}

Бинарный оператор двойного знака "меньше" (_побитовый сдвиг влево_) `<<{:tact}` возвращает целое число, бинарное представление которого является значением _левого операнда_, сдвинутым на количество битов _правого операнда_ влево. Лишние биты, сдвинутые влево, отбрасываются, а справа добавляются нулевые биты. Это более эффективный способ умножить _левый операнд_ на $2^n$, где $n$ равен _правому операнду_. Выход за максимальное значение типа [`Int{:tact}`][int] приведет к ошибке с [кодом завершения 4](/book/exit-codes#4): `Integer overflow`.

Может применяться только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two << 1; // 4
1 << 5;   // 1 * 2^5, который 32
2 << 5;   // 2 * 2^5, который 64

pow(2, 254) == (1 << 254); // true
pow(2, 254) == 1 << 254; // true, скобки не нужны из-за более высокого приоритета >> над ==
pow(2, 255) == 1 << 255; // true, но мы очень близки к переполнению!
```

:::note

  [Битовые сдвиги - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts)\
  [Манипулирование битами - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

### Сравнение {#binary-relation}

Нахождение большего, меньшего или равного значения.

#### Больше, `>` {#binary-greater}

Бинарный оператор _больше_ `>{:tact}` возвращает `true{:tact}`, если левый операнд больше правого операнда, и `false{:tact}` в противном случае. Может применяться только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two > 2; // false
-1 > -3; // true
```

#### Больше или равно, `>=` {#binary-greater-equal}

Бинарный оператор _больше или равно_ `>={:tact}` возвращает `true{:tact}`, если левый операнд больше правого операнда или равен ему, и `false{:tact}` в противном случае. Может применяться только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two >= 2; // true
-1 >= -3; // true
```

#### Меньше, `<` {#binary-less}

Бинарный оператор _меньше_ `<{:tact}` возвращает `true{:tact}`, если левый операнд меньше правого, и `false{:tact}` в противном случае. Может применяться только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two < 2; // false
-1 < -3; // false
```

#### Меньше или равно, `<=` {#binary-less-equal}

Бинарный оператор _меньше или равно_ `<={:tact}` возвращает `true{:tact}`, если левый операнд меньше или равен правому операнду, и `false{:tact}` в противном случае. Может применяться только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two <= 2; // true
-1 <= -3; // false
```

### Равенство и неравенство, `==` `!=` {#binary-equality}

Бинарный оператор равенства (_equal_) `=={:tact}` проверяет, являются ли два его операнда _равными_, возвращая результат типа [`Bool{:tact}`][bool].

Бинарный оператор неравенства (_неравенство_) `!={:tact}` проверяет, являются ли два его операнда _неравными_, возвращая результат типа [`Bool{:tact}`][bool].

Оба оператора требуют, чтобы операнды были одного типа, и не выполняют неявные преобразования типов, за исключением типов [`Cell{:tact}`][cell] и [`Slice{:tact}`][slice], которые неявно сравниваются по их хэшам.

Оба оператора могут применяться к следующему списку типов и значений:

- [`Int{:tact}`][int]
- [`Bool{:tact}`][bool]
- [`Address{:tact}`][p]
- [`Cell{:tact}`][cell], сравнение производится неявно с помощью [`.hash(){:tact}`](/ref/core-cells#cellhash)
- [`Slice{:tact}`][slice], сравнение производится неявно с помощью [`.hash(){:tact}`](/ref/core-cells#slicehash)
- [`String{:tact}`][p]
- [`map<K, V>{:tact}`](/book/maps), но только если типы ключей и значений совпадают
- [Опциональные значения и значение `null{:tact}`](/book/optionals)

```tact
// Int:
2 == 3; // false
2 != 3; // true

// Bool:
true == true;  // true
false != true; // true

// Address:
myAddress() == myAddress(); // true
myAddress() != myAddress(); // false

// Cell:
emptyCell() == emptyCell(); // true
emptyCell() != emptyCell(); // false

// Slice:
"A".asSlice() == "A".asSlice(); // true
"A".asSlice() != "A".asSlice(); // false

// String:
"A" == "A"; // true
"A" != "A"; // false

// map<K, V>:
let map1: map<Int, Int> = emptyMap();
let map2: map<Int, Int> = emptyMap();
map1 == map2; // true
map1 != map2; // false

// Опциональные значения и сами значения null
let nullable: Int? = null;
nullable == null; // true
null == null;     // true
nullable != null; // false
null != null;     // false

let anotherNullable: Int? = 5;
nullable == anotherNullable; // false
nullable != anotherNullable; // true
```

:::note

  Бинарное равенство `=={:tact}` и неравенство `!={:tact}`неявно сравнивают [карты](/book/maps) по хэшам соответствующих [ячейкам][cell] с помощью функции [`.hash(){:tact}`](/ref/core-cells#cellhash). Хотя это подходит для большинства случаев, так как большинство сериализаторов карт работают аналогично оригинальным сериализаторам блокчейна TON, возможно получение ложных отрицательных результатов при ручной сериализации карты или изменении логики сериализатора в библиотеке.

  Если необходимо гарантировать, что сравниваемые карты равны, и вы готовы заплатить значительно больше газа, используйте функцию [`map.deepEquals(){:tact}`](/book/maps#deepequals).

:::

### Побитовое AND, `&` {#binary-bitwise-and}

Бинарный оператор амперсанд (_побитовое AND_) `&{:tact}` применяет [побитовое AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND), который выполняет операцию [логического AND](#binary-logical-and) для каждой пары соответствующих битов операндов. Это полезно для сброса выбранных битов числа, где каждый бит представляет отдельный флаг или булево состояние, что позволяет "хранить" до $257$ булевых значений на одно число, поскольку все числа в Tact имеют длину $257$ бит и являются знаковыми.

Может применяться только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two & 1; // 0
4 & 1;   // 0
3 & 1;   // 1
1 & 1;   // 1

255 & 0b00001111;        // 15
0b11111111 & 0b00001111; // 15
```

:::note

  [Побитовое AND - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#AND)\
  [Манипулирование битами - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

### Побитовое XOR, `^` {#binary-bitwise-xor}

Бинарный оператор карет (_побитовое XOR_) `^{:tact}` применяет [побитовое XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR), которое выполняет операцию [логического исключающего OR](https://en.wikipedia.org/wiki/Exclusive_or) для каждой пары соответствующих битов операндов. Результат в каждой позиции будет $1$, если только один из битов равен $1$, но будет $0$, если оба бита равны $0$ или оба равны $1$. Таким образом, происходит сравнение двух битов: результатом будет $1$, если биты различны, и $0$, если они одинаковы.

Это полезно для инверсии выбранных битов операнда (также называемой переключением или переворотом), так как любой бит можно переключить, применив к нему "XOR" с $1$.

Может применяться только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two ^ 3; // 1
4 ^ 1;   // 0
3 ^ 1;   // 3
1 ^ 1;   // 0

255 ^ 0b00001111;        // 240
0b11111111 ^ 0b00001111; // 240
```

:::note

  [Побитовое XOR - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)\
  [Манипулирование битами - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

### Побитовое OR, `|` {#binary-bitwise-or}

Бинарный оператор бар (_побитовое OR_) `|{:tact}` применяет [побитовое OR](https://en.wikipedia.org/wiki/Bitwise_operation#OR), который выполняет операцию [логического OR](#binary-logical-or) для каждой пары соответствующих битов операндов. Это полезно, когда мы хотим применить определенную [битовую маску](https://en.wikipedia.org/wiki/Mask_(computing)).

Например, _побитовое OR_ обычно используется в Tact для [объединения базовых режимов с опциональными флагами](/book/message-mode#combining-modes-with-flags) путем маскирования определенных битов на $1$ для создания нужного [`mode` сообщения](/book/message-mode).

Может применяться только к значениям типа [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two | 1; // 3
4 | 1;   // 5
3 | 1;   // 3
1 | 1;   // 1

255 | 0b00001111;        // 255
0b11111111 | 0b00001111; // 255
```

:::note

  [Побитовое OR - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#OR)\
  [Манипуляция битами - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

### Логическое AND, `&&` {#binary-logical-and}

Бинарный оператор логического AND ([логическая конъюнкция](https://en.wikipedia.org/wiki/Logical_conjunction)) `&&{:tact}` возвращает `true{:tact}`, если оба операнда `true{:tact}`, и `false{:tact}` в противном случае. Это короткозамкнутый оператор, что означает, что он сразу оценивает всё выражение как `false{:tact}`, если левый операнд равен `false{:tact}`, не оценивая правый.

Может применяться только к значениям типа [`Bool{:tact}`][bool]:

```tact
let iLikeTact: Bool = true;
iLikeTact && true;  // true, оценил оба операнда
iLikeTact && false; // false, оценил оба операнда
false && iLikeTact; // false, не оценил iLikeTact
```

### Логическое OR, `||` {#binary-logical-or}

Бинарный оператор логического OR ([логическая дизъюнкция](https://en.wikipedia.org/wiki/Logical_disjunction)) `||{:tact}` возвращает `false{:tact}` только в том случае, если оба операнда равны `false{:tact}`, и `true{:tact}` в противном случае. Он имеет короткое замыкание, то есть он сразу вычисляет всё выражение как `true{:tact}`, если левый операнд равен `true{:tact}`, не оценивая правый.

Может применяться только к значениям типа [`Bool{:tact}`][bool]:

```tact
let iLikeSnails: Bool = false;
iLikeSnails || true;  // true, оценил оба операнда
iLikeSnails || false; // false, оценил оба операнда
true || iLikeSnails;  // true, не оценил iLikeSnails
```

## Тернарный оператор, `?:` {#ternary}

Условный (_тернарный_) оператор - это единственный оператор Tact, который принимает три операнда: условие, за которым следует вопросительный знак (`?{:tact}`), затем выражение, которое будет выполнено, если условие оценивается как `true{:tact}` с двоеточием (`:{:tact}`), и, наконец, выражение, которое будет выполнено, если условие оценивается как `false{:tact}`. Этот оператор часто используется в качестве альтернативы оператору [`if...else{:tact}`](/book/statements#if-else).

Условие должно быть приведено к типу [`Bool{:tact}`][bool]:

```tact
// условие
// ↓
true ? "incredibly so" : "absolutely not"; // "incredibly so"
//     ---------------   ----------------
//     ↑                 ↑
//     |                 альтернативный вариант, когда условие false
//     |
//     следствие, когда условие true

2 + 2 == 4 ? true : false; // true
```

Тернарный оператор - единственный оператор с правой ассоциативностью, помимо [операторов, связанных с присваиванием](#assignment). Это означает, что в неоднозначных ситуациях Tact будет отдавать предпочтение самой длинной подходящей последовательности. Проще говоря, это позволяет вкладывать тернарные операторы без скобок, но только для альтернативных случаев (часть, которая следует после двоеточия `:{:tact}`):

```tact
// не нужны дополнительные скобки для альтернативных случаев
false ? 1 : (false ? 2 : 3); // 3
false ? 1 : false ? 2 : 3;   // also 3
false ? 1 : true ? 2 : 3;    // 2

// нужны дополнительные скобки для следственных случаев (промежуточных частей ? и :)
false ? (false ? 1 : 2) : 3; // 3
false ? false ? 1 : 2 : 3;   // СИНТАКСИЧЕСКАЯ ОШИБКА!
true  ? (false ? 1 : 2) : 3; // 2
```

## Присваивание, `=` {#assignment}

Оператор присваивания `={:tact}` используется для присваивания значения переменной или свойству [Message](/book/structs-and-messages#messages) или [Struct](/book/structs-and-messages#structs). Присваивание является оператором и не возвращает значение.

```tact
let someVar: Int = 5;    // здесь используется оператор присваивания = ...
someVar = 4;             // ...и здесь
someVar = (someVar = 5); // СИНТАКСИЧЕСКАЯ ОШИБКА!
```

### Расширенное присваивание

Операторы расширенного (или составного) присваивания, такие как `+={:tact}`, совмещают операцию с [присваиванием](#assignment). Расширенное присваивание является оператором и не возвращает значение.

Расширенные присваивания семантически эквивалентны обычным присваиваниям, но с дополнительной операцией:

```tact
let value: Int = 5;

// это:
value += 5;
// эквивалентно этому:
value = value + 5;
```

Список расширенных операторов присваивания:

- `+={:tact}`, который использует [оператор сложения `+{:tact}`](#binary-add). Может применяться только к значениям типа [`Int{:tact}`][int].
- `-={:tact}`, который использует [оператор вычитания `-{:tact}`](#binary-subtract). Может применяться только к значениям типа [`Int{:tact}`][int].
- `*={:tact}`, который использует [оператор умножения `*{:tact}`](#binary-multiply). Может применяться только к значениям типа [`Int{:tact}`][int].
- `/={:tact}`, который использует [оператор деления `/{:tact}`](#binary-divide). Может применяться только к значениям типа [`Int{:tact}`][int].
- `%={:tact}`, который использует [оператор по модулю `%{:tact}`](#binary-modulo). Может применяться только к значениям типа [`Int{:tact}`][int].
- `&={:tact}`, который использует [побитовый оператор AND `&{:tact}`](#binary-bitwise-and). Может применяться только к значениям типа [`Int{:tact}`][int].
- `^={:tact}`, который использует [побитовый оператор XOR `^{:tact}`](#binary-bitwise-xor). Может применяться только к значениям типа [`Int{:tact}`][int].
- `|={:tact}`, который использует [побитовый оператор OR `|{:tact}`](#binary-bitwise-or). Может применяться только к значениям типа [`Int{:tact}`][int].

```tact
let value: Int = 5;

// +=
value + 5;         // добавляет 5
value = value + 5; // добавляет 5 и присваивает результат обратно
value += 5;        // также добавляет 5 и присваивает результат обратно

// -=
value - 5;         // вычитает 5
value = value - 5; // вычитает 5 и присваивает результат обратно
value -= 5;        // также вычитает 5 и присваивает результат обратно

// *=
value * 5;         // умножает на 5
value = value * 5; // умножает на 5 и присваивает результат обратно
value *= 5;        // также умножает на 5 и присваивает результат обратно

// /=
value / 5;         // делит на 5
value = value / 5; // делит на 5 и присваивает результат обратно
value /= 5;        // также делит на 5 и присваивает результат обратно

// %=
value % 5;         // получает значение по модулю 5
value = value % 5; // получает значение по модулю 5 и присваивает результат обратно
value %= 5;        // также получает значение по модулю 5 и присваивает результат обратно

// &=
value & 5;         // побитовое AND 5
value = value & 5; // побитовое AND 5 и присваивает результат обратно
value &= 5;        // также побитовое AND 5 и присваивает результат обратно

// ^=
value ^ 5;         // побитовое XOR 5
value = value ^ 5; // побитовое XOR 5 присваивает результат обратно
value ^= 5;        // также побитовое XOR 5 присваивает результат обратно

// |=
value | 5;         // побитовое OR 5
value = value | 5; // побитовое OR 5 и присваивает результат обратно
value |= 5;        // также побитовое OR 5 и присваивает результат обратно
```

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[cell]: /book/cells#cells
[slice]: /book/cells#slices
