---
title: Операторы
description: На этой странице перечислены все операторы в Tact, которые могут быть использованы в теле функции
---

import { Badge } from '@astrojs/starlight/components';

Следующие операторы могут быть использованы в любом месте тела [функции](/book/functions).

## Оператор `let` {#let}

Оператор `let{:tact}` позволяет объявлять локальные переменные с областью видимости в рамках [блока](#block).

В Tact объявление локальной переменной всегда требует начального значения. Однако указание типа можно опустить, и Tact попытается вывести его из начального значения:

```tact
let value: Int = 123; // полное объявление с типом и значением
let vInferred = 123;  // вывод типа Int

let vExplicitCtx: Context = context(); // явный тип Context, встроенный Struct
let vCtx = context();                  // вывод типа Context
```

Обратите внимание, что начальное значение `null{:tact}` может означать как пустой [`map<K, V>{:tact}`](/book/maps) с произвольными типами `K{:tact}` и `V{:tact}`, так и намеренное отсутствие любого другого значения для типа [optional](/book/optionals). Поэтому при объявлении [optional](/book/optionals) как [`map<K, V>{:tact}`](/book/maps) необходимо явно указывать тип, так как он не может быть выведен:

```tact
let vOptional: Int? = null; // явный тип Int или null
let vOptInt = 42;           // неявный тип Int
vOptInt = null;             // ОШИБКА КОМПИЛЯЦИИ!

let vMap: map<Int, Int> = emptyMap(); // явный тип map<Int, Int>
let vMapWithSerialization: map<Int as uint8, Int as uint8> = emptyMap();
```

Присвоение локальной переменной имени с подчеркиванием `_{:tact}`, делает ее значение неиспользуемым и игнорируемым. Это полезно, когда вам не нужно возвращаемое значение функции с побочными эффектами, и вы хотите явно пометить переменную как неиспользуемую. Обратите внимание, что к такому подстановочному имени переменной `_{:tact}` невозможно получить доступ:

```tact
let _ = someFunctionWithSideEffects(); // с выводом типа
let _: map<Int, Int> = emptyMap();     // с явным указанием типа

dump(_); // ОШИБКА КОМПИЛЯЦИИ! Доступ к _ невозможен
```

## Оператор `return` {#return}

Оператор `return{:tact}` завершает выполнение [функции](/book/functions) и определяет значение, которое будет возвращено вызывающей [функции](/book/functions).

```tact
// Простая обёртка для функции stdlib now()
fun getTimeFromNow(offset: Int): Int {
    return now() + offset;
}
```

## Блок

Блочный оператор используется для группировки нуля или более операторов. Блок ограничен парой фигурных скобок ("фигурные скобки", `{}{:tact}`) и содержит список из нуля или более операторов и объявлений.

Некоторые операторы, такие как [`let{:tact}`](#let) или [`return{:tact}`](#return), должны заканчиваться точкой с запятой `;{:tact}`. Однако точка с запятой в конце последнего оператора блока является необязательной и может быть опущена.

```tact
{ // <- начало блока
    // произвольные операторы:
    let value: Int = 2 + 2;
    dump(value);
} // <- конец блока

{ dump(2 + 2) } // блок, содержащий только один оператор,
                // пропущена последняя и единственная точка с запятой

{
    let nah = 3 * 3 * 3; // блок с двумя операторами,
    let yay = nah + 42   // но без последней точки с запятой
}
```

## Выражение

Оператор выражения - это выражение, используемое в месте, где ожидается оператор. Выражение вычисляется, а его результат отбрасывается — поэтому оно имеет смысл только для выражений с побочными эффектами, таких как вызов функции или обновление переменной.

```tact
dump(2 + 2); // функция stdlib
```

## Присваивание

Операторы присваивания используют [оператор присваивания](/book/operators#assignment) (`={:tact}`) или [расширенные операторы присваивания](/book/operators#augmented-assignment) (присваивание в сочетании с операцией):

```tact
let value: Int; // объявление
value = 5;      // присваивание
value += 5;     // расширенное присваивание (один из вариантов, см. ниже)
```

:::note

  Подробнее о присваивании и расширенном присваивании читайте в соответствующем разделе: [операторы присваивания](/book/operators#assignment).

:::

## Деструктурирующее присваивание

<Badge text="Доступно с версии Tact 1.6 (еще не выпущено)" variant="tip" size="medium"/><p/>

Деструктурирующее присваивание - это лаконичный способ распаковать [Structs][s] и [Messages][m] в отдельные переменные. Оно отражает [синтаксис создания экземпляра](/book/expressions#instantiation), но вместо создания новой [Struct][s] или [Message][m] она связывает каждое поле или часть полей с их соответствующими переменными.

Синтаксис основан на [операторе `let`](#let), и вместо прямого указания имени переменной требует указания типа структуры с левой стороны [оператора присваивания `={:tact}`](/book/operators#assignment), соответствующего типу структуры значения с правой стороны.

```tact {9}
// Определение Example
struct Example { number: Int }

// Произвольная вспомогательная функция
fun get42(): Example { return Example { number: 42 } }

fun basic() {
    // Базовый синтаксис деструктурирующего присваивания (слева от "="):
    let Example { number } = get42();
    //  -------   ------     -------
    //  ↑         ↑          ↑
    //  |         |          распаковывает Example Struct
    //  |         определяет переменную "number" основанную
    //  |         на поле "number" в Example Struct
    //  целевой тип структуры "Example"
    //  для распаковки полей

    // То же самое, но с созданием экземпляра
    // чтобы показать, как синтаксис деструктурирования повторяет его:
    let Example { number } = Example { number: 42 };
    //                       ----------------------
    //                       ↑
    //                       создание Example Struct

    // Приведённые выше примеры синтаксиса примерно эквивалентны
    // следующей серии операторов:
    let example = Example { number: 42 };
    let number = example.number;
}
```

Как и при [создании экземпляра](/book/expressions#instantiation), завершающая запятая допустима.

```tact
struct Example { number: Int }

fun trailblazing() {
    let Example {
        number,     // завершающая запятая в списке переменных
    } = Example {
        number: 42, // завершающая запятая в списке полей
    };
}
```

:::note

  [Расширенные операторы присваивания](/book/operators#augmented-assignment) неприменимы для таких присваиваний и поэтому будут считаться ошибками синтаксиса:

```tact
struct Example { number: Int }
fun get42(): Example { return Example { number: 42 } }

fun basic() {
    let Example { number } += get42();
    //                     ^ это приведет к ошибке синтаксического анализа:
    //                     ожидаемое "="
}
```

:::

Чтобы создать привязку под другим именем переменной, укажите его после двоеточия `:{:tact}`.

```tact
// Аналогичное определение, но на этот раз поле называется "field", а не "number"
struct Example { field: Int }

fun naming(s: Example) {
    let Example { field: varFromField } = s;
    //                   ------------     ↑
    //                   ↑                |
    //                   |                экземпляр Example Struct, полученный
    //                   |                в качестве параметра функции "naming"
    //                   определения переменной "varFromField", производной
    //                   от поля "field" в Example Struct
}
```

Обратите внимание, что порядок привязок не имеет значения — все поля сохраняют свои значения и типы под своими именами независимо от порядка их определения в соответствующих [Struct][s] или [Message][m].

```tact
// "first" идет первым, затем идет "second"
struct Two { first: Int; second: String }

fun order(s: Two) {
    let Two { second, first } = s;
    //        ------  -----
    //        ↑       ↑
    //        |       эта переменная будет иметь тип Int,
    //        |       также как и поле "first" в Struct Two
    //        эта переменная будет иметь тип String,
    //        также как и поле "second" в Struct Two
}
```

Деструктурирующее присваивание является исчерпывающим и требует указания всех полей в качестве переменных. Чтобы намеренно игнорировать некоторые поля, используйте символ подчеркивания `_{:tact}`, который отбрасывает значение рассматриваемого поля. Обратите внимание, что к такой универсальной переменной `_{:tact}` нельзя получить доступ:

```tact
// "first" идет первым, затем идет "second"
struct Two { first: Int; second: String }

fun discard(s: Two) {
    let Two { second: _, first } = s;
    //              ---
    //              ↑
    //              отбрасывает поле "second", оставляя только "first"
}
```

Чтобы полностью игнорировать остальные поля, используйте `..` в конце списка:

```tact
struct Many { one: Int; two: Int; three: Int; fans: Int }

fun ignore(s: Many) {
    let Many { fans, .. } = s;
    //               --
    //               ↑
    //               игнорирует все неуказанные поля,
    //               определяя только "fans"
}
```

:::caution

  На данный момент деструктурирование вложенных [Structs][s] или [Messages][m] не поддерживается. То есть, следующее не будут работать:

```tact
struct First { nested: Second }
struct Second { field: Int }

fun example() {
    let prep = First { nested: Second { field: 42 } };
    let First { nested: { field: thing } } = prep;
    //                  ^ это приведет к ошибке синтаксического анализа:
    //                  ожидаемое "_", "A".."Z", или "a".."z"
}
```

:::

## Ветвление

Контроль потока кода.

### `if...else` {#if-else}

:::caution

  Фигурные скобки (блоки кода) обязательны!

:::

При выполнении оператора `if...else{:tact}` сначала вычисляется указанное условие. Если вычисленное значение равно `true{:tact}`, выполняется следующий блок операторов. В противном случае, если условие принимает значение `false{:tact}`, будет выполнен необязательный блок `else{:tact}`. Если блок `else{:tact}` отсутствует, ничего не происходит, и выполнение продолжается дальше.

Обычный оператор `if{:tact}`:

```tact
// условие
// ↓
if (true) { // следствие, когда условие true
    dump(2 + 2);
}
```

С блоком `else{:tact}`:

```tact
// условие
// ↓
if (2 + 2 == 4) {
    // следствие, когда условие true
    dump(true);
} else {
    // альтернативный вариант, когда условие false
    dump(false);
}
```

С вложенными `if...else{:tact}`:

```tact
// условие
// ↓
if (2 + 2 == 3) {
    // следствие, когда условие true
    dump("3?");
//        условие2
//        ↓
} else if (2 + 2 == 4) {
    // другое следствие, когда условие2 true
    dump(true);
} else {
    // альтернативный вариант, когда и условие, и условие2 являются false
    dump(false);
}
```

:::note

  В Tact также есть тернарное выражение `?:{:tact}`, которое описано ранее в Книге: [Тернарные выражения](/book/operators#ternary).

:::

### `try...catch` {#try-catch}

Оператор `try...catch{:tact}` состоит из блока `try{:tact}` и опционального блока `catch{:tact}`, который принимает [`Int{:tact}`][int] [код выхода](/book/exit-codes) в качестве единственного аргумента. Код в блоке `try{:tact}` выполняется первым, а если он завершается с ошибкой, то выполняется код в блоке `catch{:tact}` будет выполнен, а изменения, внесенные в блоке `try{:tact}`, будут отменены, если это возможно.

:::note

  Обратите внимание, что некоторые параметры состояния TVM, такие как кодовая страница и счетчики газа, не будут восстановлены. То есть весь расход газа в блоке `try{:tact}` будет учитываться, а эффекты опкодов, изменяющих лимит газа, будут сохранены.

:::

Обычный оператор `try{:tact}`:

```tact
fun braveAndTrue() {
    // Давайте попробуем сделать что-нибудь ошибочное
    try {
        nativeThrow(42); // отбрасывание с кодом выхода 42
    }

    // Будет выполнено следующее, поскольку ошибочный код, приведенный выше, был заключен в блок try
    dump(42);
}
```

С блоком `catch (e){:tact}`:

```tact
fun niceCatch() {
    // Давайте попробуем сделать что-нибудь ошибочное
    try {
        nativeThrow(42); // отбрасывание с кодом выхода 42
    } catch (err) {
        dump(err);       // при этом будет выведен перехваченный код выхода, который равен 42
    }
}
```

С вложенными `try...catch{:tact}`:

```tact
try {
    // Подготовка x, равного 0, таким образом, чтобы компилятор Tact этого (пока!) не заметил
    let xs: Slice = beginCell().storeUint(0, 1).endCell().beginParse();
    let x: Int = xs.loadUint(1); // 0

    try {
        throw(101);     // 1. выбрасывает исключение с кодом завершения 101
    } catch (err) {     // 2. перехватывает ошибку и сохраняет код завершения (101) как err
        return err / x; // 3. делит err на x, который равен нулю, выбрасывая исключение с кодом завершения 4
    }

} catch (err) {         // 4. перехватывает новую ошибку и сохраняет код завершения (4) как err
    //   ^^^ это работает без коллизий имен, так как предыдущий err
    //       находится в другой области видимости и доступен только внутри предыдущего блока catch

    dump(err);          // 5. выводит последний перехваченный код завершения (4)
}
```

Обратите внимание, что, как и в [операторе `let{:tact}`](#let), перехваченный [код завершения](/book/exit-codes) в блоке `catch (){:tact}` можно отбросить, указав вместо него символ подчеркивания `_{:tact}`:

```tact
try {
    throw(42);
} catch (_) {
    dump("I don't know the exit code anymore");
}
```

:::note

  Подробнее о кодах завершения читайте на отдельной странице: [Коды завершения в Книге](/book/exit-codes).

:::

## Циклы

Условно повторяют определенные блоки кода несколько раз.

### `repeat` {#repeat-loop}

Цикл `repeat{:tact}` выполняет блок кода заданное количество раз. Количество повторений должно быть задано как положительное $32$-битное [`Int{:tact}`][int] в диапазоне от $1$ до $2^{31} - 1$ включительно. Если значение превышает этот диапазон, будет выброшена ошибка с [кодом завершения 5](/book/exit-codes#5), Integer out of the expected range\`.

Если указанное количество повторений равно $0$ или является отрицательным числом в диапазоне от $-2^{256}$ до $-1$ включительно, оно игнорируется, и блок кода вовсе не выполняется.

```tact
let twoPow: Int = 1;

// Повторить ровно 10 раз
repeat (10) {
    twoPow *= 2;
}

// Пропущено
repeat (-1) {
    twoPow *= 3333;
}

twoPow; // 1024
```

### `while` {#while-loop}

Цикл `while{:tact}` продолжает выполнение блока кода, пока заданное условие остается `true{:tact}`.

В следующем примере значение `x` уменьшается на $1$ $ на каждой итерации, поэтому цикл выполнится $10$ раз:

```tact
let x: Int = 10;
while (x > 0) {
    x -= 1;
}
```

### `do...until` {#do-until-loop}

Цикл `do...until{:tact}` является постпроверочным циклом, который выполняет блок кода хотя бы один раз, а затем продолжает выполнение, пока заданное условие не станет `true{:tact}`.

В следующем примере значение `x` уменьшается на $1$ на каждой итерации, поэтому цикл выполнится $10$ раз:

```tact
let x: Int = 10;
do {
    x -= 1;  // выполняет этот блок кода хотя бы один раз
} until (x <= 0);
```

### `foreach` {#foreach-loop}

Цикл `foreach{:tact}` работает с парами ключ-значение (записями) типа [`map<K, V>{:tact}`](/book/maps) в последовательном порядке: от наименьших ключей в карте к наибольшим.

Этот цикл выполняет блок кода для каждой записи в заданной карте, захватывая ключ и значение на каждой итерации. Это удобно, когда заранее неизвестно, сколько элементов содержится в карте, или если не хочется явно искать каждую запись с помощью [`.get(){:tact}`](/book/maps#get) [метода](/book/functions#extension-function) карт.

Обратите внимание, что имена захваченных пар ключ-значение на каждой итерации являются произвольными и могут быть любыми допустимыми идентификаторами Tact, при условии, что они новые в текущей области видимости. Наиболее распространенные варианты: `k` и `v`, или `key` и `value`.

В следующем примере карта `cells` содержит $4$ записи, поэтому цикл выполнится $4$ раза:

```tact
// Пустая карта
let cells: map<Int, Cell> = emptyMap();

// Настройка четырех записей
cells.set(1, beginCell().storeUint(100, 16).endCell());
cells.set(2, beginCell().storeUint(200, 16).endCell());
cells.set(3, beginCell().storeUint(300, 16).endCell());
cells.set(4, beginCell().storeUint(400, 16).endCell());

// Переменная для суммирования значений
let sum: Int = 0;

// Для каждой пары ключей и значений в карте ячеек выполните следующие действия:
foreach (key, value in cells) { // или просто k, v
    let s: Slice = value.beginParse(); // преобразование Cell в Slice
    sum += s.loadUint(16);             // суммирование значений Slice
}
dump(sum); // 1000
```

Также возможно выполнять итерации по карте в хранилище контракта, а также по картам, являющимся членами экземпляров типов [Struct](/book/structs-and-messages#structs) или [Message](/book/structs-and-messages#messages):

```tact
import "@stdlib/deploy";

struct Fizz { oh_my: map<Int, Int> }
message Buzz { oh_my: map<Int, Int> }

contract Iterated {
    oh_my: map<Int, Int>;

    receive("call to iterate!") {
        let oh_my: map<Int, Int> = emptyMap();
        oh_my.set(0, 42);
        oh_my.set(1, 27);

        self.oh_my = oh_my; // присвоение локальной карты хранилища
        let fizz = Fizz{ oh_my }; // краткая запись полей
        let buzz = Buzz{ oh_my }; // краткая запись полей

        // итерация по карте в хранилище контракта
        foreach (key, value in self.oh_my) {
            // ...
        }

        // итерация по карте, являющейся членом экземпляра Struct Fizz
        foreach (key, value in fizz.oh_my) {
            // ...
        }

        // Итерация по карте, являющейся членом экземпляра Message Buzz
        foreach (key, value in buzz.oh_my) {
            // ...
        }
    }
}
```

Обратите внимание, что, аналогично [оператору `let{:tact}`](#let), захваченные ключ или значение (или оба) могут быть отброшены с помощью подчеркивания `_{:tact}` на их месте:

```tact
// Пустая карта
let quartiles: map<Int, Int> = emptyMap();

// Настройка некоторых записей
quartiles.set(1, 25);
quartiles.set(2, 50);
quartiles.set(3, 75);

// Отбрасывание захваченных ключей
// без изменения их в самой карте
foreach (_, value in quartiles) {}

// Отбрасывание захваченных значений
// без изменения их в самой карте
foreach (key, _ in quartiles) {}

// Отбрасывание как ключей, так и значений
// без изменения их в самой карте
foreach (_, _ in quartiles) {
    // Нельзя получить доступ через _, но можно выполнять нужные операции
    // n раз, где n — текущая длина карты
}
```

:::caution

  Обратите внимание, что в данный момент `foreach{:tact}` работает только с явно указанными идентификаторами карт и вложенными конструкциями идентификаторов, такими как `foo.bar.targetMap{:tact}` или `self.baz.targetMap{:tact}`. То есть, возврат карты из функции и попытка выполнить по ней итерацию не сработает:

```tact
foreach (k, v in emptyMap()) {
//               ^ это вызовет следующую ошибку:
//                 foreach разрешен только для карт, которые являются выражениями пути,
//                 то есть идентификаторов или последовательностей прямого доступа к контракту/структуре/сообщению,
//                 например, "self.foo" или "self.structure.field"
}
```

  Попытка выполнить итерацию по карте, являющейся членом [Struct](/book/structs-and-messages#structs), возвращенной из функции, также не сработает, так как вызов функции — это выражение, а не идентификатор или вложенный доступ к идентификатору:

```tact
foreach (k, v in genCoolStruct().map) {
//               ^ это вызовет следующую ошибку:
//                 foreach разрешен только для карт, которые являются выражениями пути,
//                 то есть идентификаторов или последовательностей прямого доступа к контракту/структуре/сообщению,
//                 например, "self.foo" или "self.structure.field"
}
```

:::

:::note

  Для дополнительных примеров циклов см.: [Циклы в Tact-By-Example] (https://tact-by-example.org/04-loops).

:::

[int]: /book/integers
[s]: /book/structs-and-messages#structs
[m]: /book/structs-and-messages#messages
