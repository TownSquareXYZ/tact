---
title: Обзор системы типа
description: Каждая переменная, элемент и значение в программах Tact имеет тип
prev:
  link: /ru/book/cs/from-solidity
  label: Переход c Solidity
---

Каждая переменная, элемент и значение в программах Tact имеет тип. Это может быть:

- Один из [примитивных типов](#primitive-types)
- или [составных типов](#composite-types)

Кроме того, многие из этих типов [можно сделать обнуляемыми](#optionals).

## Примитивные типы

Tact поддерживает ряд примитивных типов данных, которые адаптированы для использования в смарт-контрактах:

- [`Int{:tact}`](/ru/book/integers) — все числа в Tact являются $257$-битными целыми числами со знаком, но [более мелкие представления](/ru/book/integers#serialization) могут использоваться для снижения затрат на хранение.
- [`Bool{:tact}`](#booleans) — классический логический тип со значениями `true{:tact}` и `false{:tact}`.
- `Address{:tact}` — стандартный [адрес смарт-контракта](https://docs.ton.org/learn/overviews/addresses#address-of-smart-contract) в блокчейне TON.
- [`Cell{:tact}`](/ru/book/cells#cells), [`Builder{:tact}`](/ru/book/cells#builders), [`Slice{:tact}`](/ru/book/cells#slices) — низкоуровневые примитивы [TVM][tvm].
- `String{:tact}` — неизменяемые текстовые строки.
- `StringBuilder{:tact}` — вспомогательный тип, позволяющий объединять строки экономичным способом.

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview

### Логические значения {#booleans}

Примитивный тип `Bool{:tact}` является классическим логическим типом, который может содержать только два значения: `true{:tact}` и `false{:tact}`. Это удобно для логических операций, а также для хранения флагов.

В Tact нет неявных преобразований типов, поэтому сложение ([`+{:tact}`](/ru/book/operators#binary-add)) двух логических значений невозможно. Кроме того, доступно множество сравнительных [операторов](/ru/book/operators), таких как:

- `&&{:tact}` для [логического И](/ru/book/operators#binary-logical-and),
- `||{:tact}` для [логического ИЛИ](/ru/book/operators#binary-logical-or),
- `!{:tact}` для [логической инверсии](/ru/book/operators#unary-inverse),
- `=={:tact}` и `!={:tact}` для проверки [равенства](/ru/book/operators#binary-equality),
- и `!!!{:tact}` для [ненулевого утверждения](/ru/book/optionals).

Сохранение логических значений в состоянии очень экономит место, так как они занимают всего 1 бит. Хранение 1000 логических значений в состоянии, [стоит](https://ton.org/docs/develop/smart-contracts/fees#how-to-calculate-fees) около $0.00072$ TON в год.

## Составные типы

Использование отдельных средств хранения часто становится громоздким, поэтому есть способы объединить несколько [примитивных типов](#primitive-types) вместе для создания составных типов:

- [Карты](#maps) — ассоциации ключей со значениями.
- [Структуры и сообщения](#structs-and-messages) — структуры данных с типизированными полями.
- [Необязательные](#optionals) — значения `null{:tact}` для переменных или полей [структур и сообщений](#structs-and-messages).

В дополнение к вышеперечисленным составным типам Tact предоставляет специальный конструктор типа [`bounced<T>{:tact}`](/ru/book/bounced), который может быть указан только в [получателях возвращенных сообщений](/ru/book/bounced).

Обратите внимание, что хотя [контракты](#contracts) и [признаки](#traits) также считаются частью системы типов Tact, их нельзя передавать, как [структуры и сообщения](#structs-and-messages). Вместо этого можно получить начальное состояние данного контракта, используя выражение [`initOf{:tact}`](/ru/book/expressions#initof).

### Карты

Тип [`map<K, V>{:tact}`][maps] используется как способ связать ключи типа `K{:tact}` с соответствующими значениями типа `V{:tact}`.

Пример [`map<K, V>{:tact}`][maps]:

```tact
let mapExample: map<Int, Int> = emptyMap(); // пустая карта с ключами и значениями типа Int
```

Подробнее об этом на отдельной странице: [карты][maps].

[карты]: /ru/book/maps

### Структуры и сообщения

[Структуры][structs] и [Сообщения][messages] - это два основных способа объединения нескольких [примитивных типов](#primitive-types) в один составной.

Пример [структуры][structs]:

```tact
struct Point {
    x: Int;
    y: Int;
}
```

Пример [сообщения][messages]:

```tact
// Собственный числовый идентификатор сообщения
message(0x11111111) SetValue {
    key: Int;
    value: Int?; // Необязательно, Int или null
    coins: Int as coins; // Сериализация в типы TL-B
}
```

Подробнее об этом на отдельной странице: [структуры и сообщения][s-n-m].

[с-н-м]: /ru/book/structs-and-messages
[Структуры]: /ru/book/structs-and-messages#structs
[сообщения]: /ru/book/structs-and-messages#messages

### Необязательные значения

Все [примитивные типы](#primitive-types), а также [структуры и сообщения](#structs-and-messages) могут быть обнуляемыми и содержать специальное значение `null{:tact}`.

Пример [необязательного][optionals] значения:

```tact
let opt: Int? = null; // Int или null, с явно присвоенным значением null
```

Подробнее об этом на отдельной странице: [необязательные значения][optionals].

[факультативы]: /ru/book/optionals

### Контракты

[Контракты](/ru/book/contracts) в Tact служат основными точками входа смарт-контрактов блокчейна TON. Они содержат все [функции](/ru/book/functions), [получатели](/ru/book/functions#getter-functions) и [приемники](/ru/book/functions#receiver-functions) контракта TON и многое другое.

Пример [контракта](/ru/book/contracts):

```tact
contract HelloWorld {
    // Постоянное состояние переменной
    counter: Int;

    // Функция-конструктор init(), где инициализируются все переменные
    init() {
        self.counter = 0;
    }

    // Внутренний приемник сообщений, который отвечает на строковое сообщение "increment"
    receive("increment") {
        self.counter += 1;
    }

    // Функция-получатель с возвращаемым типом Int
    get fun counter(): Int {
        return self.counter;
    }
}
```

Подробнее об этом на отдельной странице: [контракты](/ru/book/contracts).

### Типажи

Tact не поддерживает классическое наследование классов, но вместо этого вводит концепцию _типажей_, которые можно рассматривать как абстрактные контракты (подобно абстрактным классам в популярных объектно-ориентированных языках). Они имеют ту же структуру, что и [контракты](#contracts), но не могут [инициализировать постоянные состояния переменных](/ru/book/contracts#init-function).

Типаж также может позволить наследующему ее контракту переопределять поведение его [функций](/ru/book/functions#virtual-and-abstract-functions) и значение его [констант](/ru/book/constants#virtual-and-abstract-constants).

Пример типажа [`Ownable{:tact}`](/ru/ref/stdlib-ownable#ownable) из [`@stdlib/ownable`](/ru/ref/stdlib-ownable):

```tact
trait Ownable {
    // Постоянное состояние переменной, которую нельзя инициализировать в типаже
    owner: Address;

    // Внутренняя функция
    fun requireOwner() {
        nativeThrowUnless(132, context().sender == self.owner);
    }

    // Функция-получатель с возвращаемым типом Address
    get fun owner(): Address {
        return self.owner;
    }
}
```

И [contract](#contracts), который использует типаж [`Ownable{:tact}`](/ru/ref/stdlib-ownable#ownable):

```tact
contract Treasure with Ownable {
    // Постоянное состояние переменной, которое ДОЛЖНО быть определено в контракте
    owner: Address;

    // Функция конструктора init(), где инициализируются все переменные
    init(owner: Address) {
        self.owner = owner;
    }
}
```
