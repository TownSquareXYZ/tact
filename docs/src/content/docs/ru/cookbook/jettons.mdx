---
title: Взаимозаменяемые токены (Jettons)
description: Распространенные примеры работы со взаимозаменяемыми токенами (Jettons) в Tact
---

На этой странице перечислены распространенные примеры работы со [взаимозаменяемыми токенами (Jettons)](https://docs.ton.org/develop/dapps/asset-processing/jettons).

Jettons - это стандарты токенов в блокчейне TON, предназначенные для создания взаимозаменяемых токенов (аналогичных ERC-20 на Ethereum) с децентрализованным подходом. Они реализованы в виде пары смарт-контрактов, обычно состоящих из двух основных компонентов:

- Jetton Master Contract (мастер-контракт Jetton)
- Jetton Wallet Contract (кошелек Jetton)

Эти контракты взаимодействуют друг с другом для управления эмиссией токенов, их распределением, переводами и другими операциями, связанными с Jetton.

## Jetton Master Contract

Мастер-контракт Jetton выполняет роль центрального элемента для конкретного Jetton. Он хранит важную информацию о самом Jetton. Ключевые функции и данные, хранящиеся в мастер-контракте Jetton, включают:

- Метаданные Jetton: информация, такая как имя токена, символ, общий объем эмиссии и количество знаков после запятой.

- Выпуск и сжигание: когда создаются (впускаются) новые Jettons, Jetton Master управляет процессом создания и распределяет их по соответствующим кошелькам. Он также управляет сжиганием (уничтожением) токенов при необходимости.

- Управление эмиссией: Jetton Master отслеживает общий объем эмиссии токенов и обеспечивает корректный учет всех выпущенных Jettons.

## Jetton Wallet Contract

Контракт Jetton Wallet представляет собой токен-кошелек отдельного холдера и отвечает за управление балансом и операциями, связанными с токенами, для конкретного пользователя. Каждый пользователь или организация, владеющая Jettons будет иметь свой уникальный контракт Jetton Wallet. Ключевые функции контракта Jetton Wallet включают в себя:

- Отслеживание баланса: контракт кошелька хранит баланс токена пользователя.

- Переводы токенов: кошелек отвечает за обработку переводов токенов между пользователями. Когда пользователь отправляет жетоны, контракт Jetton Wallet обеспечивает корректный перевод и взаимодействие с кошельком получателя. Jetton Master не участвует в этом процессе и не создает узких мест. Кошельки могут эффективно использовать функцию шардирования блокчейна TON

- Сжигание токенов: Jetton Wallet взаимодействует с Jetton Master, для сжигания токенов.

- Контроль владельца: контракт кошелька принадлежит и контролируется конкретным пользователем, что означает, что только владелец кошелька может инициировать переводы или другие операции с токеном.

## Примеры

Типичные примеры работы с Jettons.

### Принятие перевода Jetton {#accepting-jetton-transfer}

Сообщение с уведомлением о переводе имеет следующую структуру:

```tact
message(0x7362d09c) JettonTransferNotification {
    // Уникальный идентификатор, используемый для отслеживания транзакций по нескольким контрактам
    // По умолчанию установлено значение 0, что означает, что мы не помечаем сообщения для отслеживания их цепочек
    queryId: Int as uint64 = 0;

    // Количество переведенных Jettons
    amount: Int as coins;

    // Адрес отправителя Jettons
    sender: Address;

    // Опциональный пользовательский payload
    forwardPayload: Slice as remaining;
}
```

Используйте функцию [receiver](/ru/book/receive), чтобы принять сообщение с уведомлением о токене.

:::caution

  Отправитель уведомления о переводе должен быть проверен!

:::

Отправитель уведомления о переводе должен быть валидирован, так как злоумышленники могут попытаться подделать уведомления от неавторизованного аккаунта.
Если валидация не будет выполнена, контракт может принять несанкционированные транзакции, что приведет к потенциальным уязвимостям в системе безопасности.

Валидация осуществляется с использованием адреса Jetton из контракта:

1. Отправитель отправляет сообщение с `0xf8a7ea5` (опкод длиной 32 бита) в свой кошелек Jetton.
2. Jetton wallet переводит средства на Jetton wallet контракта.
3. После успешного принятия перевода Jetton wallet контракта отправляет уведомление о переводе в контракт владельца.
4. Контракт валидирует сообщение Jetton.

Вы можете получить адрес кошелька Jetton контракта, используя функцию [`contractAddress(){:tact}`](/ru/ref/core-common#contractaddress) или вычислить этот адрес offchain.

Чтобы инициализировать состояние кошелька Jetton, вам понадобятся данные и код кошелька. Несмотря на то, что существует общая структура размещения исходных данных, в некоторых случаях она может отличаться, например, в случае с [USDT](#usdt-jetton-operations).

Поскольку уведомления поступают из кошелька Jetton вашего контракта, в поле `ownerAddress` следует использовать функцию [`myAddress(){:tact}`](/ru/ref/core-common#myaddress).

:::caution

  Отправка уведомлений не всегда гарантирована. По умолчанию реализация не отправляет уведомление, если значение `forwardAmount` равно нулю. Поэтому в таких случаях вы не можете полагаться на отправку уведомлений.

:::

```tact
import "@stdlib/deploy";

struct JettonWalletData {
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
    jettonWalletCode: Cell;
}

fun calculateJettonWalletAddress(
    ownerAddress: Address,
    jettonMasterAddress: Address,
    jettonWalletCode: Cell
): Address {

    let initData = JettonWalletData{
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
        jettonWalletCode,
    };

    return contractAddress(StateInit{
        code: jettonWalletCode,
        data: initData.toCell(),
    });
}

message(0x7362d09c) JettonTransferNotification {
    queryId: Int as uint64;
    amount: Int as coins;
    sender: Address;
    forwardPayload: Slice as remaining;
}

contract Example with Deployable {
    myJettonWalletAddress: Address;
    myJettonAmount: Int as coins = 0;

    init(jettonWalletCode: Cell, jettonMasterAddress: Address) {
        self.myJettonWalletAddress = calculateJettonWalletAddress(
            myAddress(),
            jettonMasterAddress,
            jettonWalletCode,
        );
    }

    receive(msg: JettonTransferNotification) {
        require(
            sender() == self.myJettonWalletAddress,
            "Notification not from your jetton wallet!",
        );

        self.myJettonAmount += msg.amount;

        // Forward excesses
        self.forward(msg.sender, null, false, null);
    }
}
```

### Отправка перевода Jetton

Перевод Jetton - это процесс отправки определённого количества жетонов с одного кошелька (контракта) на другой.

Для отправки перевода Jetton используйте функцию [`send(){:tact}`](/ru/book/send).

```tact
import "@stdlib/deploy";

message(0xf8a7ea5) JettonTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    responseDestination: Address?;
    customPayload: Cell? = null;
    forwardTonAmount: Int as coins;
    forwardPayload: Slice as remaining;
}

const JettonTransferGas: Int = ton("0.05");

struct JettonWalletData {
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
    jettonWalletCode: Cell;
}

fun calculateJettonWalletAddress(
    ownerAddress: Address,
    jettonMasterAddress: Address,
    jettonWalletCode: Cell,
): Address {

    let initData = JettonWalletData{
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
        jettonWalletCode,
    };

    return contractAddress(StateInit{
        code: jettonWalletCode,
        data: initData.toCell(),
    });
}

message Withdraw {
    amount: Int as coins;
}

contract Example with Deployable {
    myJettonWalletAddress: Address;
    myJettonAmount: Int as coins = 0;

    init(jettonWalletCode: Cell, jettonMasterAddress: Address) {
        self.myJettonWalletAddress = calculateJettonWalletAddress(
            myAddress(),
            jettonMasterAddress,
            jettonWalletCode,
        );
    }

    receive(msg: Withdraw) {
        require(
            msg.amount <= self.myJettonAmount,
            "Not enough funds to withdraw"
        );

        send(SendParameters{
            to: self.myJettonWalletAddress,
            value: JettonTransferGas,
            body: JettonTransfer{
                // Уникальный идентификатор, используемый для отслеживания транзакций по нескольким контрактам
                queryId: 42,
                // Сумма Jetton для перевода
                amount: msg.amount,
                // Куда перевести Jettons:
                // это адрес кошелька Jetton
                // владелец, а не сам кошелек Jetton
                destination: sender(),
                // Куда отправить уведомление с подтверждением успешного перевода
                // и остальная часть значения входящего сообщения
                responseDestination: sender(),
                // Может использоваться для пользовательской логики самих Jettons,
                // а без этого может быть установлено значение null
                customPayload: null,
                // Сумма перевода с JettonTransferNotification,
                // которая необходима для выполнения пользовательской логики
                forwardTonAmount: 1, // if its 0, the notification won't be sent!
                // Способ выражения во время компиляции:
                //     beginCell().storeUint(0xF, 4).endCell().beginParse()
                // Для более сложных переводов отрегулируйте соответствующим образом
                forwardPayload: rawSlice("F")
            }.toCell(),
        });
    }
}
```

### Сжигание Jetton {#burning-jetton}

Сжигание Jetton — это процесс постоянного удаления определенного количества Jetton из обращения без возможности восстановления.

```tact
import "@stdlib/deploy";

message(0x595f07bc) JettonBurn {
    queryId: Int as uint64;
    amount: Int as coins;
    responseDestination: Address?;
    customPayload: Cell? = null;
}

const JettonBurnGas: Int = ton("0.05");

struct JettonWalletData {
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
    jettonWalletCode: Cell;
}

fun calculateJettonWalletAddress(
    ownerAddress: Address,
    jettonMasterAddress: Address,
    jettonWalletCode: Cell,
): Address {

    let initData = JettonWalletData{
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
        jettonWalletCode,
    };

    return contractAddress(StateInit{
        code: jettonWalletCode,
        data: initData.toCell(),
    });
}

message ThrowAway {
    amount: Int as coins;
}

contract Example with Deployable {
    myJettonWalletAddress: Address;
    myJettonAmount: Int as coins = 0;

    init(jettonWalletCode: Cell, jettonMasterAddress: Address) {
        self.myJettonWalletAddress = calculateJettonWalletAddress(
            myAddress(),
            jettonMasterAddress,
            jettonWalletCode,
        );
    }

    receive(msg: ThrowAway) {
        require(
            msg.amount <= self.myJettonAmount,
            "Not enough funds to throw away",
        );

        send(SendParameters{
            to: self.myJettonWalletAddress,
            value: JettonBurnGas,
            body: JettonBurn{
                // Уникальный идентификатор, используемый для отслеживания транзакций по нескольким контрактам
                queryId: 42,
                // Количество Jettons для сжигания
                amount: msg.amount,
                // Куда отправить уведомление с подтверждением успешного сжигания
                // и остальная часть значения входящего сообщения
                responseDestination: sender(),
                // Может использоваться для пользовательской логики самих Jettons,
                // а без этого может быть установлено значение null
                customPayload: null,
            }.toCell(),
        });
    }
}
```

### Операции с Jetton USDT {#usdt-jetton-operations}

Операции с USDT (на TON) остаются прежними, за исключением того, что `JettonWalletData` будет иметь следующую структуру:

```tact
struct JettonWalletData {
    status: Int as uint4;
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
}

// Функция для вычисления адреса кошелька может выглядеть следующим образом:
fun calculateJettonWalletAddress(
    ownerAddress: Address,
    jettonMasterAddress: Address,
    jettonWalletCode: Cell
): Address {

    let initData = JettonWalletData{
        status: 0,
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
    };

    return contractAddress(StateInit{
        code: jettonWalletCode,
        data: initData.toCell(),
    });
}
```

### Создание метаданных Onchain

```tact
/// https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#jetton-metadata-example-offchain
fun composeJettonMetadata(
    name: String,        // полное наименование
    description: String, // текстовое описание Jetton
    symbol: String,      // символ "биржевого тикера" без префикса $, например USDT или SCALE
    image: String,       // ссылка на изображение
    // Там могут быть и другие данные, смотрите:
    // https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#jetton-metadata-attributes
): Cell {
    let dict: map<Int as uint256, Cell> = emptyMap();
    dict.set(sha256("name"), name.asMetadataCell());
    dict.set(sha256("description"), description.asMetadataCell());
    dict.set(sha256("symbol"), symbol.asMetadataCell());
    dict.set(sha256("image"), image.asMetadataCell());

    return beginCell()
        .storeUint(0, 8)                // префикс нулевого байта
        .storeMaybeRef(dict.asCell()!!) // 1 как отдельный бит, затем ссылка
        .endCell();
}

// Запускаем!
fun poorMansLaunchPad() {
    let jettonMetadata = composeJettonMetadata(
        "Best Jetton",
        "A very descriptive description describing the jetton descriptively",
        "JETTON",
        "...link to ipfs or somewhere trusted...",
    );
}

// Добавляет к String один нулевой байт и преобразует ее в Cell
// Префикс нулевого байта используется для выражения метаданных в различных стандартах, таких как NFT или Jetton
inline extends fun asMetadataCell(self: String): Cell {
    return beginTailString().concat(self).toCell();
}
```

:::note[Useful [Полезные ссылки:]

  [Стандарт передачи данных токенов в TEPs](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#jetton-metadata-attributes)

:::

:::tip[Hey [Обратите внимание!]

Не нашли подходящий пример использования Jetton? Есть интересные идеи для реализации? [Мы будем рады вашим предложениям!](https://github.com/tact-lang/tact/issues)

:::
