---
title: Невзаимозаменяемые токены (NFT)
description: Распространенные примеры работы с невзаимозаменяемыми токенами (NFT) в Tact
---

На этой странице перечислены распространенные примеры работы с [NFT](https://docs.ton.org/develop/dapps/asset-processing/nfts).

## Принятие передачи права собственности на NFT

Уведомление о передаче права собственности на NFT имеет следующую структуру:

```tact
message(0x05138d91) NFTOwnershipAssigned {
    previousOwner: Address;
    forwardPayload: Slice as remaining;
}
```

Для принятия уведомления используйте функцию [receiver](/book/receive).

:::caution

  Отправитель уведомления должен быть валидирован!

:::

Валидация может быть выполнена двумя способами:

1. Сохраните адрес NFT напрямую и выполните проверку по нему.

```tact
import "@stdlib/deploy";

message(0x05138d91) NFTOwnershipAssigned {
    previousOwner: Address;
    forwardPayload: Slice as remaining;
}

contract SingleNft with Deployable {
    nftItemAddress: Address;

    init(nftItemAddress: Address) {
        self.nftItemAddress = nftItemAddress;
    }

    receive(msg: NFTOwnershipAssigned) {
        require(self.nftItemAddress == sender(), "NFT contract is not the sender");

        // ваша логика обработки уведомления о передаче права собственности на NFT
    }
}
```

2. Используйте [`StateInit{:tact}`](/book/expressions#initof) и производный адрес элемента NFT.

```tact
import "@stdlib/deploy";

message(0x05138d91) NFTOwnershipAssigned {
    previousOwner: Address;
    forwardPayload: Slice as remaining;
}

struct NFTItemInitData {
    index: Int as uint64;
    collectionAddress: Address;
}

inline fun calculateNFTAddress(index: Int, collectionAddress: Address, nftCode: Cell): Address {
    let initData = NFTItemInitData{
        index,
        collectionAddress,
    };

    return contractAddress(StateInit{code: nftCode, data: initData.toCell()});
}

contract NftInCollection with Deployable {
    nftCollectionAddress: Address;
    nftItemIndex: Int as uint64;
    nftCode: Cell;

    init(nftCollectionAddress: Address, nftItemIndex: Int, nftCode: Cell) {
        self.nftCollectionAddress = nftCollectionAddress;
        self.nftItemIndex = nftItemIndex;
        self.nftCode = nftCode;
    }

    receive(msg: NFTOwnershipAssigned) {
        let expectedNftAddress = calculateNFTAddress(self.nftItemIndex, self.nftCollectionAddress, self.nftCode); // or you can even store expectedNftAddress
        require(expectedNftAddress == sender(), "NFT contract is not the sender");

        // ваша логика обработки уведомления о передаче права собственности на NFT
    }
}
```

Поскольку исходная структура данных NFT может различаться, первый подход часто является более подходящим.

## Передача элемента NFT

Для передачи NFT используйте функцию [`send(){:tact}`](/book/send).

```tact
import "@stdlib/deploy";

message(0x5fcc3d14) NFTTransfer {
    queryId: Int as uint64;
    newOwner: Address; // адрес нового владельца элемента NFT.
    responseDestination: Address; // адрес для отправки ответа с подтверждением успешной передачи и остатком монет из входящего сообщения.
    customPayload: Cell? = null; //  необязательные пользовательские данные. В большинстве случаев должны быть
    forwardAmount: Int as coins; // количество нанотонов, которое нужно отправить новому владельцу.
    forwardPayload: Slice as remaining; // необязательные пользовательские данные, которые следует отправить новому владельцу.
}

contract Example {
    nftItemAddress: Address;

    init(nftItemAddress: Address) {
        self.nftItemAddress = nftItemAddress;
    }

    // ... добавьте больше кода из предыдущих примеров...

    receive("transfer") {
        send(SendParameters{
            to: self.nftItemAddress,
            value: ton("0.1"),
            body: NFTTransfer{
                queryId: 42,
                // FIXME: Измените это в соответствии с вашими потребностями
                newOwner: sender(),
                responseDestination: myAddress(),
                customPayload: null,
                forwardAmount: 1,
                forwardPayload: rawSlice("F"), // precomputed beginCell().storeUint(0xF, 4).endCell().beginParse()
            }.toCell(),
        });
    }
}
```

## Получение статической информации об NFT

Обратите внимание, что блокчейн TON не позволяет контрактам вызывать друг друга с использованием [геттеров](https://docs.tact-lang.org/book/contracts#getter-functions).
Для получения данных от другого контракта необходимо обмениваться сообщениями.

```tact
message(0x2fcb26a2) NFTGetStaticData {
    queryId: Int as uint64;
}

message(0x8b771735) NFTReportStaticData {
    queryId: Int as uint64;
    index: Int as uint256;
    collection: Address;
}

struct NFTItemInitData {
    index: Int as uint64;
    collectionAddress: Address;
}

inline fun calculateNFTAddress(index: Int, collectionAddress: Address, nftCode: Cell): Address {
    let initData = NFTItemInitData{
        index,
        collectionAddress,
    };

    return contractAddress(StateInit{code: nftCode, data: initData.toCell()});
}

contract Example {
    nftCollectionAddress: Address;
    nftItemIndex: Int as uint64;
    nftCode: Cell;

    init(nftCollectionAddress: Address, nftItemIndex: Int, nftCode: Cell) {
        self.nftCollectionAddress = nftCollectionAddress;
        self.nftItemIndex = nftItemIndex;
        self.nftCode = nftCode;
    }

    // ... добавьте больше кода из предыдущих примеров...

    receive("get static data") {
        // FIXME: Укажите корректный адрес("[NFT_ADDRESS]") здесь
        let nftAddress = sender();
        send(SendParameters{
            to: nftAddress,
            value: ton("0.1"),
            body: NFTGetStaticData{
                queryId: 42,
            }.toCell(),
        });
    }

    receive(msg: NFTReportStaticData) {
        let expectedNftAddress = calculateNFTAddress(msg.index, msg.collection, self.nftCode);
        require(expectedNftAddress == sender(), "NFT contract is not the sender");

        // Сохраните статические данные NFT или выполните другое действие
    }
}
```

## Получение параметров роялти NFT

Параметры роялти NFT описаны [здесь](https://github.com/ton-blockchain/TEPs/blob/master/text/0066-nft-royalty-standard.md).

```tact
message(0x693d3950) NFTGetRoyaltyParams {
    queryId: Int as uint64;
}

message(0xa8cb00ad) NFTReportRoyaltyParams {
    queryId: Int as uint64;
    numerator: Int as uint16;
    denominator: Int as uint16;
    destination: Address;
}

contract Example {
    nftCollectionAddress: Address;

    init(nftCollectionAddress: Address) {
        self.nftCollectionAddress = nftCollectionAddress;
    }

    // ...добавьте больше кода из предыдущих примеров...

    receive("get royalty params") {
        send(SendParameters{
            to: self.nftCollectionAddress,
            value: ton("0.1"),
            body: NFTGetRoyaltyParams{
                queryId: 42,
            }.toCell(),
        });
    }

    receive(msg: NFTReportRoyaltyParams) {
        require(self.nftCollectionAddress == sender(), "NFT collection contract is not the sender");

        // Выполните действие с сообщением
    }
}
```

## Методы коллекции NFT

:::caution

  Эти методы не являются частью какого-либо стандарта и будут работать только с [этой конкретной реализацией](https://github.com/ton-blockchain/token-contract/blob/main/nft/nft-collection.fc). Пожалуйста, учитывайте это перед их использованием.

:::

Обратите внимание, что использовать эти методы могут только владельцы NFT.

### Развертывание NFT

```tact
message(0x1) NFTDeploy {
    queryId: Int as uint64;
    itemIndex: Int as uint64;
    amount: Int as coins; // сумма, которая будет отправлена при развертывании nft
    nftContent: Cell;
}

contract Example {
    nftCollectionAddress: Address;

    init(nftCollectionAddress: Address) {
        self.nftCollectionAddress = nftCollectionAddress;
    }

    // ... добавьте больше кода из предыдущих примеров...

    receive("deploy") {
        send(SendParameters{
            to: self.nftCollectionAddress,
            value: ton("0.14"),
            body: NFTDeploy{
                queryId: 42,
                itemIndex: 42,
                amount: ton("0.1"),
                nftContent: beginCell().endCell() // FIXME: Должно быть вашим содержимым, в основном сгенерированным оффчейн
            }.toCell(),
        });
    }
}
```

### Изменение владельца

```tact
message(0x3) NFTChangeOwner {
    queryId: Int as uint64;
    newOwner: Address;
}

contract Example {
    nftCollectionAddress: Address;

    init(nftCollectionAddress: Address) {
        self.nftCollectionAddress = nftCollectionAddress;
    }

    // ... добавьте больше кода из предыдущих примеров...

    receive("change owner") {
        send(SendParameters{
            to: self.nftCollectionAddress,
            value: ton("0.05"),
            body: NFTChangeOwner{
                queryId: 42,
                // FIXME: Укажите корректный адрес("NEW_OWNER_ADDRESS") здесь
                newOwner: sender(),
            }.toCell(),
        });
    }
}
```

## Создание метаданных Onchain

### NFT коллекция {#onchain-metadata-nft-collection}

```tact
/// https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-metadata-attributes
fun composeCollectionMetadata(
    name: String,        // полное наименование
    description: String, // текстовое описание NFT
    image: String,       // ссылка на изображение
    // Там могут быть другие данные, смотрите:
    // https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-metadata-attributes
): Cell {
    let dict: map<Int as uint256, Cell> = emptyMap();
    dict.set(sha256("name"), name.asMetadataCell());
    dict.set(sha256("description"), description.asMetadataCell());
    dict.set(sha256("image"), image.asMetadataCell());

    return beginCell()
        .storeUint(0, 8)                // префикс нулевого байта
        .storeMaybeRef(dict.asCell()!!) // 1 как отдельный бит, затем ссылка
        .endCell();
}

// Запускаем!
fun poorMansLaunchPad() {
    let collectionMetadata = composeCollectionMetadata(
        "Best Collection",
        "A very descriptive description describing the collection descriptively",
        "...link to ipfs or somewhere trusted...",
    );
}

// Добавляет к String один нулевой байт и преобразует ее в Cell
// Префикс нулевого байта используется для выражения метаданных в различных стандартах, таких как NFT или Jetton
inline extends fun asMetadataCell(self: String): Cell {
    return beginTailString().concat(self).toCell();
}
```

:::note[Useful [Полезные ссылки:]

  [Стандарт передачи данных токенов в TEPs](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-metadata-attributes)\
  [Off-chain метаданные NFT от GetGems](https://github.com/getgems-io/nft-contracts/blob/main/docs/metadata.md)

:::

### NFT элемент {#onchain-metadata-nft-item}

```tact
/// https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-metadata-attributes
fun composeItemMetadata(
    name: String,        // полное наименование
    description: String, // текстовое описание NFT
    image: String,       // ссылка на изображение
    // Там могут быть другие данные, смотрите:
    // https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-metadata-attributes
): Cell {
    let dict: map<Int as uint256, Cell> = emptyMap();
    dict.set(sha256("name"), name.asMetadataCell());
    dict.set(sha256("description"), description.asMetadataCell());
    dict.set(sha256("image"), image.asMetadataCell());

    return beginCell()
        .storeUint(0, 8)                // префикс нулевого байта
        .storeMaybeRef(dict.asCell()!!) // 1 как отдельный бит, затем ссылка
        .endCell();
}

// Запускаем!
fun poorMansLaunchPad() {
    let itemMetadata = composeItemMetadata(
        "Best Item",
        "A very descriptive description describing the item descriptively",
        "...link to ipfs or somewhere trusted...",
    );
}

// Добавляет к String один нулевой байт и преобразует ее в Cell
// Префикс нулевого байта используется для выражения метаданных в различных стандартах, таких как NFT или Jetton
inline extends fun asMetadataCell(self: String): Cell {
    return beginTailString().concat(self).toCell();
}
```

:::note[Useful [Полезные ссылки:]

  [Стандарт передачи данных токенов в TEPs](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#nft-metadata-attributes)\
  [Off-chain метаданные NFT от GetGems](https://github.com/getgems-io/nft-contracts/blob/main/docs/metadata.md)

:::

:::tip[Hey [Обратите внимание!]

  Не нашли подходящий пример взаимодействия с NFT? Есть идеи крутых реализаций? [Мы будем рады вашим предложениям!](https://github.com/tact-lang/tact/issues)

:::
