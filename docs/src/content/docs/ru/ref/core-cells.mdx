---
title: Cells, Builders и Slices
description: Различные функции работы с ячейками, билдерами и срезами из основной библиотеки Tact
---

import { Badge } from '@astrojs/starlight/components';

[`Ячейка (Cell){:tact}`][cell] - это низкоуровневый [примитив][p], который представляет данные в блокчейне TON. Ячейки состоят из $1023$ бит данных и могут иметь до $4$ ссылок на другие ячейки. Они доступны только для чтения, неизменяемы и не могут иметь циклических ссылок.

[`Билдер (Builder){:tact}`][builder] - это неизменяемый [примитив][p] для создания ячеек, а [`Срез (Slice){:tact}`][slice] - это изменяемый [примитив][p] для их парсинга.

:::note

  Будьте очень внимательны при создании и парсинге ячеек вручную, и всегда документируйте их желаемую структуру: строгий порядок значений и типов для сериализации и десериализации.

  Для этого опытным пользователям рекомендуется использовать [Type Language - Binary (TL-B)][tlb].

  Всем пользователям рекомендуется использовать [структуры][struct] и их [методы](/ru/book/functions#extension-function), такие как [`Struct.toCell(){:tact}`](#structtocell) и [`Struct.fromCell(){:tact}`](#structfromcell) вместо ручного создания и парсинга ячеек, потому что [Structs][struct] и [Messages][message] ближе всего к [живыми TL-B схемам ваших контрактов](/ru/book/cells#cnp-structs).

:::

## beginCell

```tact
fun beginCell(): Builder;
```

Создает новый пустой [`Builder{:tact}`][builder].

Пример использования:

```tact
let fizz: Builder = beginCell();
```

## emptyCell

```tact
fun emptyCell(): Cell;
```

Создает и возвращает пустую [`Cell{:tact}`][cell] (без данных и ссылок). Алиас для `beginCell().endCell(){:tact}`.

Пример использования:

```tact
let fizz: Cell = emptyCell();
let buzz: Cell = beginCell().endCell();

fizz == buzz; // true
```

## emptySlice

```tact
fun emptySlice(): Slice;
```

Создает и возвращает пустой [`Slice{:tact}`][slice] (без данных и ссылок). Алиас для `emptyCell().asSlice(){:tact}`.

Пример использования:

```tact
let fizz: Slice = emptySlice();
let buzz: Slice = emptyCell().asSlice();

fizz == buzz; // true
```

## Cell.beginParse

```tact
extends fun beginParse(self: Cell): Slice;
```

Функция расширения для [`Cell{:tact}`][cell].

Открывает [`Cell{:tact}`][cell] для парсинга и возвращает как [`Slice{:tact}`][slice].

Пример использования:

```tact
let c: Cell = emptyCell();
let fizz: Slice = c.beginParse();
```

## Cell.hash

```tact
extends fun hash(self: Cell): Int;
```

Функция расширения для [`Cell{:tact}`][cell].

Вычисляет и возвращает значение [`Int{:tact}`][int] хэша [SHA-256][sha-2] [стандартного представления `Cell{:tact}`][std-repr] заданной [`Cell{:tact}`][cell].

Пример использования:

```tact
let c: Cell = emptyCell();
let fizz: Int = c.hash();
```

## Cell.asSlice

```tact
extends fun asSlice(self: Cell): Slice;
```

Функция расширения для [`Cell{:tact}`][cell].

Преобразует Cell в [`Slice{:tact}`][slice] и возвращает его. Алиас для `self.beginParse(){:tact}`.

Пример использования:

```tact
let c: Cell = emptyCell();
let fizz: Slice = c.asSlice();
```

## Builder.endCell

```tact
extends fun endCell(self: Builder): Cell;
```

Функция расширения для [`Builder{:tact}`][builder].

Преобразует [`Builder{:tact}`][builder] в обычный [`Cell{:tact}`][cell].

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Cell = b.endCell();
```

## Builder.storeUint

```tact
extends fun storeUint(self: Builder, value: Int, bits: Int): Builder;
```

Функция расширения для [`Builder{:tact}`][builder].

Сохраняет беззнаковое `bits`-битное `value` в копию [`Builder{:tact}`][builder] для $0 ≤$ `bits` $≤ 256$. Возвращает эту копию.

Попытки сохранить отрицательное `value` или указать недостаточное или выходящее за пределы значение `bits` число вызывают исключение с [кодом завершения 5](/ru/book/exit-codes#5): `Integer out of expected range`.

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeUint(42, 6);
```

## Builder.storeInt

```tact
extends fun storeInt(self: Builder, value: Int, bits: Int): Builder;
```

Функция расширения для [`Builder{:tact}`][builder].

Сохраняет знаковое `bits`-битное `value` в копию [`Builder{:tact}`][builder] для $0 ≤$ `bits` $≤ 257$. Возвращает эту копию.

Попытки указать недостаточное или выходящее за пределы значение `bits` вызываю исключение с [кодом завершения 5](/ru/book/exit-codes#5): `Integer out of expected range`.

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeInt(42, 7);
```

## Builder.storeBool

```tact
extends fun storeBool(self: Builder, value: Bool): Builder;
```

Функция расширения для [`Builder{:tact}`][builder].

Сохраняет [`Bool{:tact}`][bool] `value` в копию [`Builder{:tact}`][builder]. Записывает $1$ как один бит, если `value` - `true{:tact}`, и записывает $0$ в противном случае. Возвращает эту копию [`Builder{:tact}`][builder].

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeBool(true);  // записывает 1
let buzz: Builder = b.storeBool(false); // записывает 0
```

## Builder.storeBit

<Badge text="Доступно с версии Tact 1.5" variant="tip" size="medium"/><p/>

```tact
extends fun storeBit(self: Builder, value: Bool): Builder;
```

Функция расширения для [`Builder{:tact}`][builder]. Алиас для [`Builder.storeBool(){:tact}`](#builderstorebool).

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeBit(true);  // записывает 1
let buzz: Builder = b.storeBit(false); // записывает 0
```

## Builder.storeBuilder

```tact
extends fun storeBuilder(self: Builder, cell: Builder): Builder;
```

Функция расширения для [`Builder{:tact}`][builder].

Добавляет все данные из [`Builder{:tact}`][builder] `cell` в копию [`Builder{:tact}`][builder]. Возвращает эту копию.

Пример использования:

```tact
let b: Builder = beginCell().storeCoins(42);
let fizz: Builder = beginCell().storeBuilder(b);
b.endCell() == fizz.endCell(); // true
```

## Builder.storeSlice

```tact
extends fun storeSlice(self: Builder, cell: Slice): Builder;
```

Функция расширения для [`Builder{:tact}`][builder].

Сохраняет [`Slice{:tact}`][slice] `cell` в копии [`Builder{:tact}`][builder]. Возвращает эту копию.

Пример использования:

```tact
let b: Builder = beginCell();
let s: Slice = emptyCell().asSlice();
let fizz: Builder = b.storeSlice(s);
```

## Builder.storeCoins

```tact
extends fun storeCoins(self: Builder, value: Int): Builder;
```

Функция расширения для [`Builder{:tact}`][builder].

Сохраняет (сериализует) беззнаковое [`Int{:tact}`][int] `value` в диапазоне $0 .. 2^{120} - 1$ в копию [`Builder{:tact}`][builder]. Сериализация `value` состоит из $4$-битного беззнакового big-endian целого числа $l$, которое является наименьшим целым числом $l ≥ 0$, таким, что `value` $< 2^{8 _ l}$, за которым следует $8 _ l$-битное беззнаковое big-endian, представляющее `value`. Возвращает копию [`Builder{:tact}`][builder].

Попытки сохранить значение `value`, выходящее за пределы допустимого диапазона, вызывают исключение с [кодом завершения 5](/ru/book/exit-codes#5): `Integer out of expected range`.

Это самый распространенный способ хранения [нанотонкоинов] (/book/integers#nanotoncoin).

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeCoins(42);
```

:::note[Useful [Полезные ссылки:]

  [Специальный тип сериализации `coins`](/ru/book/integers#serialization-coins)

:::

## Builder.storeAddress

```tact
extends fun storeAddress(self: Builder, address: Address): Builder;
```

Функция расширения для [`Builder{:tact}`][builder].

Сохраняет `address` в копии [`Builder{:tact}`][builder]. Возвращает эту копию.

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeAddress(myAddress());
```

## Builder.storeRef

```tact
extends fun storeRef(self: Builder, cell: Cell): Builder;
```

Функция расширения для [`Builder{:tact}`][builder].

Сохраняет ссылку `cell` в копии [`Builder{:tact}`][builder]. Возвращает эту копию.

Поскольку одна [`Cell{:tact}`][cell] может содержать до $4$ ссылок, попытки сохранить больше вызывают исключение с [кодом завершения 8](/ru/book/exit-codes#8): `Cell overflow`.

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeRef(emptyCell());
```

## Builder.storeMaybeRef

<Badge text="Доступно с версии Tact 1.5" variant="tip" size="medium"/><p/>

```tact
extends fun storeMaybeRef(self: Builder, cell: Cell?): Builder;
```

Функция расширения для [`Builder{:tact}`][builder].

Если `cell` не `null{:tact}`, сохраняет $1$ как один бит, а затем ссылку на `cell` в копию [`Builder{:tact}`][builder]. Возвращает эту копию.

Если `cell` равна `null{:tact}`, сохраняет только $0$ как один бит в копию [`Builder{:tact}`][builder]. Возвращает эту копию.

Поскольку одна [`Cell{:tact}`][cell] может содержать до $4$ ссылок, попытки сохранить больше вызывают исключение с [кодом завершения 8](/ru/book/exit-codes#8): `Cell overflow`.

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Builder = b
    .storeMaybeRef(emptyCell()) // сохраняет один бит со значением 1, затем пустую ячейку
    .storeMaybeRef(null);       // сохраняет только один бит со значением 0
```

## Builder.refs

```tact
extends fun refs(self: Builder): Int;
```

Функция расширения для [`Builder{:tact}`][builder].

Возвращает количество ссылок на ячейки, уже сохранённых в [`Builder{:tact}`][builder] в виде [`Int{:tact}`][int].

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Int = b.refs(); // 0
```

## Builder.bits

```tact
extends fun bits(self: Builder): Int;
```

Функция расширения для [`Builder{:tact}`][builder].

Возвращает количество бит данных, уже сохранённых в [`Builder{:tact}`][builder] в виде [`Int{:tact}`][int].

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Int = b.bits(); // 0
```

## Builder.asSlice

```tact
extends fun asSlice(self: Builder): Slice;
```

Функция расширения для [`Builder{:tact}`][builder].

Преобразует [`Builder{:tact}`][builder] в [`Slice{:tact}`][slice] и возвращает его. Алиас для `self.endCell().beginParse(){:tact}`.

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Slice = b.asSlice();
```

## Builder.asCell

```tact
extends fun asCell(self: Builder): Cell;
```

Функция расширения для [`Builder{:tact}`][builder].

Преобразует [`Builder{:tact}`][builder] в [`Cell{:tact}`][cell] и возвращает его. Алиас для `self.endCell(){:tact}`.

Пример использования:

```tact
let b: Builder = beginCell();
let fizz: Cell = b.asCell();
```

## Slice.loadUint

```tact
extends mutates fun loadUint(self: Slice, l: Int): Int;
```

Расширяющая функция мутации для [`Slice{:tact}`][slice].

Загружает и возвращает беззнаковое `l`-битное [`Int{:tact}`][int] из [`Slice{:tact}`][slice] для $0 ≤$ `l` $≤ 256$.

Попытки указать значение `l`, выходящее за пределы допустимого диапазона, вызывают исключение с [кодом завершения 5](/ru/book/exit-codes#5): `Integer out of expected range`.

Попытки загрузить больше данных, чем содержится в [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Пример использования:

```tact
let s: Slice = beginCell().storeUint(42, 7).asSlice();
let fizz: Int = s.loadUint(7);
```

## Slice.preloadUint

```tact
extends fun preloadUint(self: Slice, l: Int): Int;
```

Функция расширения для [`Slice{:tact}`][slice].

Предварительно загружает и возвращает беззнаковый `l`-битный [`Int{:tact}`][int] из [`Slice{:tact}`][slice] для $0 ≤$ `l` $≤ 256$. Не изменяет [`Slice{:tact}`][slice].

Попытки указать значение `l`, выходящее за пределы допустимого диапазона, вызывают исключение с [кодом завершения 5](/ru/book/exit-codes#5): `Integer out of expected range`.

Попытки предзагрузить больше данных, чем содержится в [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Пример использования:

```tact
let s: Slice = beginCell().storeUint(42, 7).asSlice();
let fizz: Int = s.preloadUint(7);
```

## Slice.loadInt

```tact
extends mutates fun loadInt(self: Slice, l: Int): Int;
```

Расширяющая функция мутации для [`Slice{:tact}`][slice].

Загружает и возвращает знаковое `l`-битное [`Int{:tact}`][int] из [`Slice{:tact}`][slice] для $0 ≤$ `l` $≤ 257$.

Попытки указать значение `l`, выходящее за пределы допустимого диапазона, вызывают исключение с [кодом завершения 5](/ru/book/exit-codes#5): `Integer out of expected range`.

Попытки загрузить больше данных, чем содержится в [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Пример использования:

```tact
let s: Slice = beginCell().storeInt(42, 7).asSlice();
let fizz: Int = s.loadInt(7);
```

## Slice.preloadInt

```tact
extends fun preloadInt(self: Slice, l: Int): Int;
```

Функция расширения для [`Slice{:tact}`][slice].

Предварительно загружает и возвращает знаковое `l`-битное [`Int{:tact}`][int] из [`Slice{:tact}`][slice] для $0 ≤$ `l` $≤ 257$. Не изменяет [`Slice{:tact}`][slice].

Попытки указать значение `l`, выходящее за пределы допустимого диапазона, вызывают исключение с [кодом завершения 5](/ru/book/exit-codes#5): `Integer out of expected range`.

Попытки предзагрузить больше данных, чем содержится в [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Пример использования:

```tact
let s: Slice = beginCell().storeInt(42, 7).asSlice();
let fizz: Int = s.preloadInt(7);
```

## Slice.loadBits

```tact
extends mutates fun loadBits(self: Slice, l: Int): Slice;
```

Расширяющая функция мутации для [`Slice{:tact}`][slice].

Загружает $0 ≤$ `l` $≤ 1023$ бит из [`Slice{:tact}`][slice] и возвращает их как отдельный [`Slice{:tact}`][slice].

Попытки указать значение `l`, выходящее пределы допустимого диапазона, вызывают исключение с [кодом завершения 5](/ru/book/exit-codes#5): `Integer out of expected range`.

Попытки загрузить больше данных, чем содержится в [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Пример использования:

```tact
let s: Slice = beginCell().storeInt(42, 7).asSlice();
let fizz: Slice = s.loadBits(7);
```

## Slice.preloadBits

```tact
extends fun preloadBits(self: Slice, l: Int): Slice;
```

Функция расширения для [`Slice{:tact}`][slice].

Предзагружает $0 ≤$ `l` $≤ 1023$ бит из [`Slice{:tact}`][slice] и загружает его как отдельный [`Slice{:tact}`][slice]. Не изменяет оригинальный [`Slice{:tact}`][slice].

Попытки указать значение `l`, выходящее за пределы допустимого диапазона, вызывают исключение с [кодом завершения 5](/ru/book/exit-codes#5): `Integer out of expected range`.

Попытки предзагрузить больше данных, чем содержится в [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Пример использования:

```tact
let s: Slice = beginCell().storeInt(42, 7).asSlice();
let fizz: Slice = s.preloadBits(7);
```

## Slice.skipBits

```tact
extends mutates fun skipBits(self: Slice, l: Int);
```

Расширяющая функция мутации для [`Slice{:tact}`][slice].

Загружает все, кроме первых $0 ≤$ `l` $≤ 1023$ бит из [`Slice{:tact}`][slice].

Попытки указать значение `l`, выходящее за пределы допустимого диапазона, вызывают исключение с [кодом завершения 5](/ru/book/exit-codes#5): `Integer out of expected range`.

Попытки загрузить больше данных, чем содержится в [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Пример использования:

```tact
let s: Slice = beginCell().storeInt(42, 7).asSlice();
s.skipBits(5);                   // все, кроме первых 5 бит
let fizz: Slice = s.loadBits(1); // загружает только 1 бит
```

## Slice.loadBool

```tact
extends mutates fun loadBool(self: Slice): Bool;
```

Расширяющая функция мутации для [`Slice{:tact}`][slice].

Загружает один бит и возвращает значение [`Bool{:tact}`][bool] из [`Slice{:tact}`][slice]. Считывает `true{:tact}`, если загруженный бит равен $1$, и считывает `false{:tact}` в противном случае.

Попытки загрузить такой [`Bool{:tact}`][bool], если [`Slice{:tact}`][slice] его не содержит, вызывают исключение с [кодом завершения 8](/ru/book/exit-codes#8): `Cell overflow`.

Попытки загрузить больше данных, чем содержится в [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Пример использования:

```tact
let s: Slice = beginCell().storeBool(true).asSlice();
let fizz: Bool = s.loadBool(); // true
```

## Slice.loadBit

<Badge text="Доступно с версии Tact 1.5" variant="tip" size="medium"/><p/>

```tact
extends mutates fun loadBit(self: Slice): Bool;
```

Расширяющая функция мутации для [`Slice{:tact}`][slice]. Алиас для [`Slice.loadBool(){:tact}`](#sliceloadbool).

Пример использования:

```tact
let s: Slice = beginCell().storeBit(true).asSlice();
let fizz: Bool = s.loadBit(); // true
```

## Slice.loadCoins

```tact
extends mutates fun loadCoins(self: Slice): Int;
```

Расширяющая функция мутации для [`Slice{:tact}`][slice].

Загружает и возвращает [сериализованное](#builderstorecoins) беззнаковое значение [`Int{:tact}`][int] в диапазоне $0 .. 2^{120} - 1$ из [`Slice{:tact}`][slice]. Это значение обычно представляет собой сумму в [нанотонкоинах](/ru/book/integers#nanotoncoin).

Попытки загрузить такое [`Int{:tact}`][int], если [`Slice{:tact}`][slice] его не содержит, вызывают исключение с [кодом завершения 8](/ru/book/exit-codes#8): `Cell overflow`.

Попытки загрузить больше данных, чем содержится в [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Пример использования:

```tact
let s: Slice = beginCell().storeCoins(42).asSlice();
let fizz: Int = s.loadCoins();
```

:::note[Useful [Полезные ссылки:]

  [Специальный тип сериализации `coins`](/ru/book/integers#serialization-coins)

:::

## Slice.loadAddress

```tact
extends mutates fun loadAddress(self: Slice): Address;
```

Расширяющая функция мутации для [`Slice{:tact}`][slice].

Загружает и возвращает [`Address{:tact}`][p] из [`Slice{:tact}`][slice].

Попытки загрузить такой [`Address{:tact}`][p] если [`Slice{:tact}`][slice] его не содержит, вызывают исключение с [кодом завершения 8](/ru/book/exit-codes#8): `Cell overflow`.

Попытки загрузить больше данных, чем содержится в [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Пример использования:

```tact
let s: Slice = beginCell().storeAddress(myAddress()).asSlice();
let fizz: Address = s.loadAddress();
```

## Slice.loadRef

```tact
extends mutates fun loadRef(self: Slice): Cell;
```

Расширяющая функция мутации для [`Slice{:tact}`][slice].

Загружает следующую ссылку из [`Slice{:tact}`][slice] как [`Cell{:tact}`][cell].

Попытки загрузить такую ссылку [`Cell{:tact}`][cell], если [`Slice{:tact}`][slice] не содержит ее, вызывают исключение с [кодом завершения 8](/ru/book/exit-codes#8): `Cell overflow`.

Попытки загрузить больше данных, чем содержится в [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Примеры использования:

```tact
let s1: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Cell = s1.loadRef();

let s2: Slice = beginCell()
    .storeRef(emptyCell())
    .storeRef(s1.asCell())
    .asSlice();
let ref1: Cell = s2.loadRef();
let ref2: Cell = s2.loadRef();
ref1 == ref2; // false
```

## Slice.preloadRef

```tact
extends fun preloadRef(self: Slice): Cell;
```

Функция расширения для [`Slice{:tact}`][slice].

Предзагружает следующую ссылку из [`Slice{:tact}`][slice] как [`Cell{:tact}`][cell]. Не изменяет оригинал [`Slice{:tact}`][slice].

Попытки предзагрузить такую ссылку [`Cell{:tact}`][cell], если [`Slice{:tact}`][slice] не содержит ее, вызывают исключение с [кодом завершения 8](/ru/book/exit-codes#8): `Cell overflow`.

Попытки предзагрузить больше данных, чем содержится в [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Примеры использования:

```tact
let s1: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Cell = s1.preloadRef(); // не изменял s1

let s2: Slice = beginCell()
    .storeRef(emptyCell())
    .storeRef(s1.asCell())
    .asSlice();
let ref1: Cell = s2.preloadRef();
let ref2: Cell = s2.preloadRef();
ref1 == ref2; // true
```

## Slice.refs

```tact
extends fun refs(self: Slice): Int;
```

Функция расширения для [`Slice{:tact}`][slice].

Возвращает количество ссылок в [`Slice{:tact}`][slice] как [`Int{:tact}`][int].

Пример использования:

```tact
let s: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Int = s.refs();
```

## Slice.bits

```tact
extends fun bits(self: Slice): Int;
```

Функция расширения для [`Slice{:tact}`][slice].

Возвращает количество бит данных в [`Slice{:tact}`][slice] как [`Int{:tact}`][int].

Пример использования:

```tact
let s: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Int = s.bits();
```

## Slice.empty

```tact
extends fun empty(self: Slice): Bool;
```

Функция расширения для [`Slice{:tact}`][slice].

Проверяет, является ли [`Slice{:tact}`][slice] пустым (т.е. не содержит ни бит данных и ни ссылок на ячейки). Возвращает `true{:tact}`, если он пуст, и `false{:tact}` в противном случае.

Пример использования:

```tact
let s: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Bool = s.empty();                     // false
let buzz: Bool = beginCell().asSlice().empty(); // true
```

:::note

  В отличие от [`Slice.endParse(){:tact}`](#sliceendparse), эта функция не вызывает исключений, даже если [`Slice{:tact}`][slice] пустой.

:::

## Slice.dataEmpty

```tact
extends fun dataEmpty(slice: Slice): Bool;
```

Функция расширения для [`Slice{:tact}`][slice].

Проверяет, не содержит ли [`Slice{:tact}`][slice] какие-либо биты данных. Возвращает `true{:tact}`, если данные отсутствуют, и `false{:tact}` в противном случае.

Пример использования:

```tact
let s: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Bool = s.dataEmpty();  // true

let s2: Slice = beginCell().storeInt(42, 7).asSlice();
let buzz: Bool = s2.dataEmpty(); // false
```

## Slice.refsEmpty

```tact
extends fun refsEmpty(slice: Slice): Bool;
```

Функция расширения для [`Slice{:tact}`][slice].

Проверяет, не содержит ли [`Slice{:tact}`][slice] ссылок. Возвращает `true{:tact}`, если ссылки отсутствуют, и `false{:tact}` в противном случае.

Пример использования:

```tact
let s: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Bool = s.refsEmpty();                     // false
let buzz: Bool = beginCell().asSlice().refsEmpty(); // true
```

## Slice.endParse

```tact
extends fun endParse(self: Slice);
```

Функция расширения для [`Slice{:tact}`][slice].

Проверяет, является ли [`Slice{:tact}`][slice] пустым (т.е. не содержит ни бит данных и ни ссылок на ячейки). Если нет, вызывает исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Примеры использования:

```tact {2,6}
let emptyOne: Slice = emptySlice();
emptyOne.endParse(); // ничего, так как он пуст

let paul: Slice = "Fear is the mind-killer".asSlice();
try {
    paul.endParse(); // выдает код завершения 9
}
```

## Slice.hash

```tact
extends fun hash(self: Slice): Int;
```

Функция расширения для [`Slice{:tact}`][slice].

Вычисляет и возвращает значение [`Int{:tact}`][int] для [SHA-256][sha-2] хэша [стандартного представления `Cell{:tact}`][std-repr] данного [`Slice{:tact}`][slice].

Пример использования:

```tact
let s: Slice = beginCell().asSlice();
let fizz: Int = s.hash();
```

## Slice.asCell

```tact
extends fun asCell(self: Slice): Cell;
```

Функция расширения для [`Slice{:tact}`][slice].

Преобразует [`Slice{:tact}`][slice] в [`Cell{:tact}`][cell] и возвращает его. Алиас для `beginCell().storeSlice(self).endCell(){:tact}`.

Пример использования:

```tact
let s: Slice = beginCell().asSlice();
let fizz: Cell = s.asCell();
let buzz: Cell = beginCell().storeSlice(s).endCell();

fizz == buzz; // true
```

## Address.asSlice

```tact
extends fun asSlice(self: Address): Slice;
```

Функция расширения для [`Address{:tact}`][p].

Преобразует [`Address{:tact}`][p] в [`Slice{:tact}`][slice] и возвращает его. Алиас для `beginCell().storeAddress(self).asSlice(){:tact}`.

Пример использования:

```tact
let a: Address = myAddress();
let fizz: Slice = a.asSlice();
let buzz: Slice = beginCell().storeAddress(a).asSlice();

fizz == buzz; // true
```

## Struct.toCell

```tact
extends fun toCell(self: Struct): Cell;
```

Функция расширения для любого типа структуры [Struct][struct].

Преобразует [Struct][struct] в [`Cell{:tact}`][cell] и возвращает его.

Пример использования:

```tact
struct GuessCoin {
    probably: Int as coins;
    nothing: Int as coins;
}

fun coinCell(): Cell {
    let s: GuessCoin = GuessCoin{ probably: 42, nothing: 27 };
    let fizz: Cell = s.toCell();

    return fizz; // "x{12A11B}"
}
```

## Struct.toSlice

<Badge text="Доступно с версии Tact 1.5" variant="tip" size="medium"/><p/>

```tact
extends fun toSlice(self: Struct): Slice;
```

Функция расширения для любого типа структуры [Struct][struct].

Преобразует [Struct][struct] в [`Slice{:tact}`][slice] и возвращает его. Алиас для `self.toCell().asSlice(){:tact}`.

Пример использования:

```tact
struct GuessCoin {
    probably: Int as coins;
    nothing: Int as coins;
}

fun coinSlice(): Slice {
    let s: GuessCoin = GuessCoin{ probably: 42, nothing: 27 };
    let fizz: Slice = s.toSlice();

    return fizz; // "CS{Cell{000612a11b} bits: 0..24; refs: 0..0}"
}
```

## Struct.fromCell

```tact
extends fun fromCell(self: Struct, cell: Cell): Struct;
```

Функция расширения для любого типа структуры [Struct][struct].

Преобразует [`Cell{:tact}`][cell] в указанный [Struct][struct] и возвращает этот [Struct][struct].

Попытки передать [`Cell{:tact}`][cell] с макетом, отличным от указанного [Struct][struct], или загрузить больше данных, чем содержит [`Cell{:tact}`][cell], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Примеры использования:

```tact
struct GuessCoin {
    probably: Int as coins;
    nothing: Int as coins;
}

fun directParse(payload: Cell): GuessCoin {
    return GuessCoin.fromCell(payload);
}

fun cautiousParse(payload: Cell): GuessCoin? {
    let coin: GuessCoin? = null;
    try {
        coin = GuessCoin.fromCell(payload);
    } catch (e) {
        dump("Cell payload doesn't match GuessCoin Struct!");
    }
    return coin;
}
```

## Struct.fromSlice

```tact
extends fun fromSlice(self: Struct, slice: Slice): Struct;
```

Функция расширения для любого типа структуры [Struct][struct].

Преобразует [`Slice{:tact}`][slice] в указанную [Struct][struct] и возвращает эту [Struct][struct].

Попытки передать [`Slice{:tact}`][slice] с макетом, отличным от указанной [Struct][struct], или загрузить больше данных, чем содержит [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Примеры использования:

```tact
struct GuessCoin {
    probably: Int as coins;
    nothing: Int as coins;
}

fun directParse(payload: Slice): GuessCoin {
    return GuessCoin.fromSlice(payload);
}

fun cautiousParse(payload: Slice): GuessCoin? {
    let coin: GuessCoin? = null;
    try {
        coin = GuessCoin.fromSlice(payload);
    } catch (e) {
        dump("Slice payload doesn't match GuessCoin Struct!");
    }
    return coin;
}
```

## Message.toCell

```tact
extends fun toCell(self: Message): Cell;
```

Функция расширения для любого типа сообщения [Message][message].

Преобразует [Message][message] в [`Cell{:tact}`][cell] и возвращает его.

Пример использования:

```tact
message GuessCoin {
    probably: Int as coins;
    nothing: Int as coins;
}

fun coinCell(): Cell {
    let s: GuessCoin = GuessCoin{ probably: 42, nothing: 27 };
    let fizz: Cell = s.toCell();

    return fizz; // "x{AB37107712A11B}"
}
```

## Message.toSlice

<Badge text="Доступно с версии Tact 1.5" variant="tip" size="medium"/><p/>

```tact
extends fun toSlice(self: Message): Slice;
```

Функция расширения для любого типа сообщения [Message][message].

Преобразует [Message][message] в [`Slice{:tact}`][slice] и возвращает его. Алиас для `self.toCell().asSlice(){:tact}`.

Пример использования:

```tact
message GuessCoin {
    probably: Int as coins;
    nothing: Int as coins;
}

fun coinSlice(): Slice {
    let s: GuessCoin = GuessCoin{ probably: 42, nothing: 27 };
    let fizz: Slice = s.toSlice();

    return fizz; // "CS{Cell{000eab37107712a11b} bits: 0..56; refs: 0..0}"
}
```

## Message.fromCell

```tact
extends fun fromCell(self: Message, cell: Cell): Message;
```

Функция расширения для любого типа сообщения [Message][message].

Преобразует [`Cell{:tact}`][cell] в указанный [Message][message] и возвращает этот [Message][message].

Попытки передать [`Cell{:tact}`][cell] с макетом, отличным от указанного [Message][message], или загрузить больше данных, чем содержит [`Cell{:tact}`][cell], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Примеры использования:

```tact
message(0x777) TripleAxe {
    prize: Int as uint32;
}

fun directParse(payload: Cell): TripleAxe {
    return TripleAxe.fromCell(payload);
}

fun cautiousParse(payload: Cell): TripleAxe? {
    let coin: TripleAxe? = null;
    try {
        coin = TripleAxe.fromCell(payload);
    } catch (e) {
        dump("Cell payload doesn't match TripleAxe Message!");
    }
    return coin;
}
```

## Message.fromSlice

```tact
extends fun fromSlice(self: Message, slice: Slice): Message;
```

Функция расширения для любого типа сообщения [Message][message].

Преобразует [`Slice{:tact}`][slice] в указанный [Message][message] и возвращает этот [Message][message].

Попытки передать [`Slice{:tact}`][slice] с макетом, отличным от указанного [Message][message], или загрузить больше данных, чем содержит [`Slice{:tact}`][slice], вызывают исключение с [кодом завершения 9](/ru/book/exit-codes#9): `Cell underflow`.

Примеры использования:

```tact
message(0x777) TripleAxe {
    prize: Int as uint32;
}

fun directParse(payload: Slice): TripleAxe {
    return TripleAxe.fromSlice(payload);
}

fun cautiousParse(payload: Slice): TripleAxe? {
    let coin: TripleAxe? = null;
    try {
        coin = TripleAxe.fromSlice(payload);
    } catch (e) {
        dump("Slice payload doesn't match TripleAxe Message!");
    }
    return coin;
}
```

[p]: /ru/book/types#primitive-types
[bool]: /ru/book/types#booleans
[int]: /ru/book/integers
[cell]: /ru/book/cells#cells
[builder]: /ru/book/cells#builders
[slice]: /ru/book/cells#slices
[map]: /ru/book/maps
[struct]: /ru/book/structs-and-messages#structs
[message]: /ru/book/structs-and-messages#messages
[std-repr]: /ru/book/cells#cells-representation
[tlb]: https://docs.ton.org/develop/data-formats/tl-b-language
[sha-2]: https://en.wikipedia.org/wiki/SHA-2#Hash_standard
