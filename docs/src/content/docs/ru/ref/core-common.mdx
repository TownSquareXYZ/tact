---
title: Общие функции
description: Часто используемые глобальные статические функции из основной библиотеки Tact
---

Список наиболее часто используемых встроенных [глобальных статических функций](/book/functions#global-static-functions).

## Контекстные

### now

```tact
fun now(): Int
```

Возвращает текущее [время Unix](https://en.wikipedia.org/wiki/Unix_time).

Пример использования:

```tact
let timeOffset: Int = now() + 1000; // тысяча секунд от now()
```

### myBalance

```tact
fun myBalance(): Int;
```

Возвращает баланс [nanoToncoin](/book/integers#nanotoncoin) смарт-контракта, который был в начале [фазы вычислений](https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase) текущей транзакции.

Пример использования:

```tact
let iNeedADolla: Int = myBalance();
```

:::caution

  Помните, что [все функции отправки сообщений](/book/send#message-sending-functions) Tact могут изменить баланс _фактического_ контракта, но они _не_ будут обновлять значение, возвращаемое этой функцией.

:::

### myAddress

```tact
fun myAddress(): Address;
```

Возвращает адрес текущего смарт-контракта как [`Address{:tact}`][p].

Пример использования:

```tact
let meMyselfAndI: Address = myAddress();
```

### sender

```tact
fun sender(): Address;
```

Возвращает [`Address{:tact}`][p] отправителя текущего сообщения.

Пример использования:

```tact
contract MeSee {
    receive() {
        let whoSentMeMessage: Address = sender();
    }
}
```

:::caution

  Поведение не определено для [функций получения](/book/contracts#getter-functions), поскольку они не могут иметь отправителя и не могут отправлять сообщения.

:::

:::note

  Чтобы сократить потребление газа, предпочитайте использовать эту функцию вместо вызова [`context().sender{:tact}`](#context), когда вам нужно знать только отправителя сообщения.

:::

### context

```tact
fun context(): Context;
```

Возвращает `Context{:tact}` [структуру](/book/structs-and-messages#structs), которая состоит из:

| Поле      | Тип                       | Описание                                                                                                                                                                                                                                                                                                                                |
| :-------- | :------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `bounced` | [`Bool{:tact}`][bool]     | [Возвращает](https://ton.org/docs/learn/overviews/addresses#bounceable-vs-non-bounceable-addresses) флаг входящего сообщения.                                                                                                                                                                                                           |
| `sender`  | [`Address{:tact}`][p]     | Внутренний адрес отправителя в блокчейне TON.                                                                                                                                                                                                                                                                                           |
| `value`   | [`Int{:tact}`][int]       | Количество [nanoToncoin](/book/integers#nanotoncoin) в сообщении.                                                                                                                                                                                                                                                                       |
| `raw`     | [`Slice{:tact}`][slice]   | Оставшаяся часть сообщения как [`Slice{:tact}`][slice]. Следует из [внутренней структуры сообщения](https://docs.ton.org/develop/smart-contracts/messages#message-layout) TON, начиная с пункта назначения [`Address{:tact}`][p] (`dest:MsgAddressInt ` в [обозначении TL-B](https://docs.ton.org/develop/data-formats/tl-b-language)). |

Пример использования:

```tact
let ctx: Context = context();
require(ctx.value != 68 + 1, "Недопустимое количество nanoToncoin, пока!");
```

:::note

  Обратите внимание, что если вам нужно только узнать, кто отправил сообщение, используйте функцию [`sender(){:tact}`](#sender), так как она потребляет меньше газа.

:::

## Адресация

### newAddress

```tact
fun newAddress(chain: Int, hash: Int): Address;
```

Создает новый [`Address{:tact}`][p] на основе [`chain` id](https://ton-blockchain.github.io/docs/#/overviews/TON_blockchain_overview) и закодированного [SHA-256](/ref/core-math#sha256) [значения `hash`](https://docs.ton.org/learn/overviews/addresses#account-id).

Эта функция пытается разрешить постоянные значения во время [компиляции](/ref/core-comptime) всякий раз, когда это возможно.

Пример использования:

```tact
let oldTonFoundationAddr: Address =
    newAddress(0, 0x83dfd552e63729b472fcbcc8c45ebcc6691702558b68ec7527e1ba403a0f31a8);
    //         ↑  ------------------------------------------------------------------
    //         |  ↑
    //         |  sha-256 хэш пакета init контракта (StateInit)
    //         chain id: 0 эот воркчейн, -1 это мастерчейн
```

:::caution

  Этот метод выдает ошибку с [кодом выхода 136](/book/exit-codes#136), если `chain` недействителен, или с [кодом выхода 137](/book/exit-codes#137), если `chain` указывает на мастерчейн ($-1$) без включенной [поддержки мастерчейна](/book/masterchain).

:::

:::note[Useful Полезные ссылки:]

  [`chain` (Идентификатор воркчейна) в TON Docs](https://docs.ton.org/learn/overviews/addresses#workchain-id)\
[`hash` (Идентификатор аккаунта) в TON Docs](https://docs.ton.org/learn/overviews/addresses#account-id)\
[Пакет инициализации контракта (`StateInit{:tact}`)](/book/expressions#initof)

:::

### contractAddress

```tact
fun contractAddress(s: StateInit): Address;
```

Вычисляет [`Address{:tact}`][p] смарт-контракта в воркчейне $0$ на основе его [`StateInit{:tact}`](/book/expressions#initof).

Пример использования:

```tact
let foundMeSome: Address = contractAddress(initOf SomeContract());
```

### contractAddressExt

```tact
fun contractAddressExt(chain: Int, code: Cell, data: Cell): Address;
```

Вычисляет [`Address{:tact}`][p] смарт-контракта на основе идентификатора `chain`, `code` контракта и начального состояния `data` контракта. Используйте выражение [`initOf{:tact}`](/book/expressions#initof) для получения начального `code` и начальных `data` данного контракта.

Пример использования:

```tact
let initPkg: StateInit = initOf SomeContract();
let hereBeDragons: Address = contractAddressExt(0, initPkg.code, initPkg.data);
```

:::caution

  Этот метод выдает ошибку с [кодом выхода 136](/book/exit-codes#136), если `chain` недействителен, или с [кодом выхода 137](/book/exit-codes#137), если `chain` указывает на мастерчейн ($-1$) без включенной [поддержки мастерчейна](/book/masterchain).

:::

:::note

  Чтобы эта функция работала, параметр компилятора `debug` должен быть установлен на `true{:tact}` для текущего проекта в [файле конфигурации](/book/config).\
Подробнее об отладке читайте на специальной странице: [Отладка](/book/debug).

:::

## Комуникация

### send

```tact
fun send(params: SendParameters);
```

[Помещает сообщение](/book/send#outbound-message-processing) в очередь для отправки с использованием [`SendParameters{:tact}`](/book/send) [структуры](/book/structs-and-messages#structs).

Пример использования:

```tact
send(SendParameters{
    to: sender(),    // обратно отправителю,,
    value: ton("1"), // с 1 Toncoin (1_000_000_000 nanoToncoin),
                     // и без тела сообщения
});
```

:::note[Useful Полезные ссылки

  [Отправка сообщений в Книге](/book/send)\
[Сообщение `mode` в Книге](/book/message-mode)\
[Общение с одним контрактом в подготовительной книге](/cookbook/single-communication)

:::

### emit

```tact
fun emit(body: Cell);
```

[Помещает сообщение](/book/send#outbound-message-processing) `body` в очередь для отправки во внешний мир с целью его регистрации и последующего анализа off-chain. Сообщение не имеет получателя и является более экономичным по сравнению с использованием любых других функций отправки сообщений Tact.

Пример использования:

```tact
emit("Поймай меня, если сможешь, мистер Холмс".asComment()); // asComment() преобразует строку в ячейку
```

:::note

  Для анализа вызовов `emit(){:tact}` необходимо просмотреть [внешние сообщения](/book/external), созданные контрактом.

  Подробнее: [Ведение журнала с помощью `emit(){:tact}`](/book/debug#logging).

:::

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[нарезать]: /book/cells#slices
