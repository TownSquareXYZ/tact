---
title: Отладка
description: Различные функции отладки из основной библиотеки Tact
---

Список функций, обычно используемых для отладки смарт-контрактов в Tact.

Подробнее об отладке читайте на специальной странице: [Отладка](/book/debug).

## require

```tact
fun require(condition: Bool, error: String);
```

Проверяет `condition` и выдает ошибку с [кодом выхода](/book/exit-codes), сгенерированным из сообщения `error`, если `condition` равно `false{:tact}`. В ином случае ничего не делает.

Алгоритм генерации кода выхода работает следующим образом:

- Сначала получается [SHA-256](https://en.wikipedia.org/wiki/SHA-2#Hash_standard) хэш сообщения `error` [`String{:tact}`][p].
- Затем его значение считывается как 32-битное [от большего к меньшему](https://en.wikipedia.org/wiki/Endianness) число по модулю $63000$ плюс $1000$, в таком порядке.
- Наконец, оно помещается в файл отчета о компиляции `.md`, который находится вместе с другими артефактами компиляции в каталогах `outputs/` или `build/` вашего проекта.

Сгенерированный код выхода гарантированно находится за пределами общего диапазона $0 - 255$, зарезервированного для ошибок контракта TVM и Tact, что позволяет отличать коды выхода от `require(){:tact}` и любых других [стандартных кодов выхода](/book/exit-codes).

Примеры использования:

```tact
// now() должен возвращать значение больше 1000, иначе будет выдано сообщение об ошибке
require(now() > 1000, "Мы находимся в первых 1000 секундах 1 января 1970 года!");

try {
    // ледующее никогда не будет истинным, поэтому этот require всегда будет выдавать
    require(now() < -1, "Время — иллюзия. Обеденное время вдвойне.");
} catch (e) {
    // e будет вне диапазона 0-255
    dump(e);
}
```

## dump

```tact
fun dump(arg);
```

Выводит аргумент `arg` в отладочную консоль контракта. Оценивается только в том случае, если параметр `debug` в [файле конфигурации](/book/config) установлен в `true{:json}`, в противном случае ничего не делает.

Эта функция требует больших вычислительных затрат и потребляет много газа, поскольку она выводит место, из которого она была вызвана, т. е. имя файла, номера строк и столбцов, а также исходное выражение, которое было аргументом `arg`.

Может применяться к следующему списку типов и значений:

- [`Int{:tact}`][int]
- [`Bool{:tact}`][bool]
- [`Address{:tact}`][p]
- [`Cell{:tact}`][cell], [`Builder{:tact}`][builder] или [`Slice{:tact}`][slice]
- [`String{:tact}`][p] или [`StringBuilder{:tact}`][p]
- [`map<K, V>{:tact}`](/book/maps)
- [Необязательные и значение `null{:tact}`](/book/optionals)
- `void`, которое неявно возвращается, когда функция не имеет определенного возвращаемого значения

Примеры использования:

```tact
// Int
dump(42); // выводит:
          // Файл filename.tact:2:1
          // dump(42)
          // 42

// Bool
dump(true);
dump(false);

// Адрес
dump(myAddress());

// Ячейка, строитель или срез
dump(emptyCell());  // Ячейка
dump(beginCell());  // Строитель
dump(emptySlice()); // Срез

// Строка или StringBuilder
dump("Hello, my name is..."); // Строка
dump(beginTailString());      // StringBuilder

// Карты
let m: map<Int, Int> = emptyMap();
m.set(2 + 2, 4);
dump(m);

// Специальные значения
dump(null);
dump(emit("msg".asComment())); // Поскольку функция emit() не возвращает значение, dump() выведет #DEBUG#: void.
```

:::note[Useful ссылки:]

  [Отладка с помощью `dump(){:tact}`](/book/debug#tests-dump)

:::

## dumpStack

```tact
fun dumpStack();
```

Выводит общую глубину стека и до $255$ его значений сверху в отладочную консоль контракта. Значения располагаются снизу вверх: от самого глубокого значения слева до самого верхнего значения справа. Оценивается только в том случае, если параметр `debug` в [файле конфигурации](/book/config) установлен в `true{:json}`, в противном случае ничего не делает.

Пример использования:

```tact
dumpStack(); // выводит:
             // Файл filename.tact:1:1
             // dumpStack()
             // стек(3 значения) : 100000000 C{96...C7} 0
```

:::note[Useful Полезные ссылки:]

  [Отладка с помощью `dump(){:tact}`](/book/debug#tests-dump)\
[Функции сборки](/book/assembly-functions)

:::

## throw

```tact
fun throw(code: Int);
```

Псевдоним для [`nativeThrow(){:tact}`](#nativethrow).

## nativeThrow

```tact
fun nativeThrow(code: Int);
```

Выдает исключение с кодом ошибки, равным `code`. Выполнение текущего контекста останавливается (операторы после `nativeThrow` не будут выполнены), и управление будет передано первому блоку [`try...catch{:tact}`](/book/statements#try-catch) в стеке вызовов. Если среди вызывающих функций нет блока `try{:tact}` или `try...catch{:tact}`, [TVM](https://docs.ton.org/learn/tvm-instructions/tvm-overview) завершит транзакцию.

Попытки указать `code` за пределами диапазона $0 - 65535$ вызовут исключение с [кодом выхода 5](/book/exit-codes#5): `Целое число вне ожидаемого диапазона`.

Примеры использования:

```tact {2,7}
fun thisWillTerminate() {
    nativeThrow(42); // выбрасывание с кодом выхода 42
}

fun butThisDoesNot() {
    try {
        nativeThrow(42); // выбрасывание с кодом выхода 42    }

    // ... логика выполнения ...
}
```

## nativeThrowIf

```tact
fun nativeThrowIf(code: Int, condition: Bool);
```

Аналогично [`nativeThrow(){:tact}`](#nativethrow), но выбрасывает исключение условно, когда `condition` равно `true{:tact}`. В противном случае не выбрасывает.

Попытки указать `code` за пределами диапазона $0 - 65535$ вызывают исключение с [кодом выхода 5](/book/exit-codes#5): `Целое число выходит за пределы ожидаемого диапазона`.

Примеры использования:

```tact {2,7}
fun thisWillTerminate() {
    nativeThrowIf(42, true); // выбрасывание с кодом выхода 42
}

fun butThisDoesNot() {
    try {
        nativeThrowIf(42, true); // выбрасывание с кодом выхода 422
    }
    // ... логика выполнения ...
}
```

## nativeThrowUnless

```tact
fun nativeThrowUnless(code: Int, condition: Bool);
```

Аналогично [`nativeThrow(){:tact}`](#nativethrow), но выбрасывает исключение условно, когда `condition` равно `true{:tact}`. В противном случае не выбрасывает.

Попытки указать `code` за пределами диапазона $0 - 65535$ вызывают исключение с [кодом выхода 5](/book/exit-codes#5): `Целое число выходит за пределы ожидаемого диапазона`.

Примеры использования:

```tact {2,7}
fun thisWillTerminate() {
    nativeThrowUnless(42, false); // выбрасывание с кодом выхода 42
}

fun butThisDoesNot() {
    try {
        nativeThrowUnless(42, false); // выбрасывание с кодом выхода 42
    }
    // ... логика выполнения ...
}
```

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[клетка]: /book/cells#cells
[строитель]: /book/cells#builders
[нарезать]: /book/cells#slices
