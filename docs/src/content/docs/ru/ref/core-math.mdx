---
title: Математика
description: Различные вспомогательные математические функции из основной библиотеки Tact
---

Различные вспомогательные математические функции

## min

```tact
fun min(x: Int, y: Int): Int;
```

Вычисляет и возвращает [минимум](https://en.wikipedia.org/wiki/Maximum_and_minimum) из двух [`Int{:tact}`][int] значений `x` и `y`.

Примеры использования:

```tact
min(1, 2);        // 1
min(2, 2);        // 2
min(007, 3);      // 3
min(0x45, 3_0_0); // 69, хорошо
//  ↑     ↑
//  69    300
```

## max

```tact
fun max(x: Int, y: Int): Int;
```

Вычисляет и возвращает [максимум](https://en.wikipedia.org/wiki/Maximum_and_minimum) двух [`Int{:tact}`][int] значений `x` и `y`.

Примеры использования:

```tact
max(1, 2);        // 2
max(2, 2);        // 2
max(007, 3);      // 7
max(0x45, 3_0_0); // 300
//  ↑     ↑
//  69    300
```

## abs

```tact
fun abs(x: Int): Int
```

Вычисляет и возвращает [абсолютное значение](https://en.wikipedia.org/wiki/Absolute_value) из [`Int{:tact}`][int] значения `x`.

Примеры использования:

```tact
abs(42);        // 42
abs(-42);       // 42
abs(-(-(-42))); // 42
```

## log

```tact
fun log(num: Int, base: Int): Int;
```

Вычисляет и возвращает [логарифм](https://en.wikipedia.org/wiki/Logarithm) числа `num` $> 0$ с основанием `base` $≥ 1$. Результаты [округляются в меньшую сторону](https://en.wikipedia.org/wiki/Rounding#Rounding_down). Передача неположительного значения `num` или `base` меньше $1$ приводит к ошибке с [кодом выхода 5](/book/exit-codes#5): `Целое число вне ожидаемого диапазона`.

Примеры использования:

```tact
log(1000, 10); // 3, так как 10^3 равно 1000
//  ↑     ↑             ↑       ↑
//  num   base          base    num

log(1001, 10);  // 3
log(999, 10);   // 2
try {
  log(-1000, 10); // выдает код выхода 5 из-за неположительного num
}
log(1024, 2);   // 10
try {
  log(1024, -2);  // выдает код выхода 5 из-за основания меньше 1
}
```

:::note

  Обратите внимание, что если вам нужно получить только логарифмы по основанию $2$, используйте функцию [`log2(){:tact}`](#log2), так как она более экономична.

:::

## log2

```tact
fun log2(num: Int): Int;
```

Аналогично [`log(){:tact}`](#log), но устанавливает `основание` равным $2$.

Пример использования:

```tact
log2(1024); // 10, так как 2^10 равно 1024
//   ↑                ↑       ↑
//   num              base₂   num
```

:::note

  Чтобы сократить потребление газа, предпочитайте использовать эту функцию вместо вызова [`log(){:tact}`](#log), когда вам нужно получить только логарифмы по основанию $2$.

:::

## pow

```tact
fun pow(base: Int, exp: Int): Int;
```

Вычисляет и возвращает [возведение в степень](https://en.wikipedia.org/wiki/Expontiation) с двумя числами: `base` и показатель степени (или _power_) `exp`. Показатель степени `exp` должен быть неотрицательным, иначе будет выдана ошибка с [кодом выхода 5](/book/exit-codes#5): `Целое число выходит за пределы ожидаемого диапазона`.

Обратите внимание, что эта функция работает как во время выполнения, так и во время [компиляции](/ref/core-comptime).

Пример использования:

```tact
contract Example {
    // Постоянные состояния переменных
    p23: Int = pow(2, 3); // возводит 2 в третью степень, что равно 8
    one: Int = pow(5, 0); // возводит 5 в степень 0, что всегда дает 1
                          // работает во время компиляции!

    // Внутренний приемник сообщений, который принимает сообщение ExtMsg
    receive() {
        pow(self.p23, self.one + 1); // 64, работает и во время выполнения!
        pow(0, -1);                  // ОШИБКА! Код выхода 5: целое число вне ожидаемого диапазона    }
}
```

:::note

  Обратите внимание, что если вам нужно получить только степени $2$, используйте функцию [`pow2(){:tact}`](#pow2), так как она более экономична.

:::

:::note

  Список функций, которые работают только во время компиляции: [API Comptime](/ref/core-comptime).

:::

## pow2

```tact
fun pow2(exp: Int): Int;
```

Аналогично [`pow(){:tact}`](#pow), но устанавливает `base` в $2$. Работает как во время выполнения, так и во время [компиляции](/ref/core-comptime).

Примеры использования:

```tact
contract Example {
    // Постоянные состояния переменных
    p23: Int = pow2(3); // возводит 2 в третью степень, что равно 8
    one: Int = pow2(0); // возводит 2 в степень 0, что всегда дает 1
                        // работает во время компиляции!

    // Внутренний приемник сообщений, который принимает сообщение ExtMsg
    receive() {
        pow2(self.one + 1); // 4, аботает и во время выполнения!
        pow2(-1);           // ОШИБКА! Код выхода 5: Целое число вне ожидаемого диапазона
    }
}
```

:::note

  Чтобы сократить потребление газа, предпочтительнее использовать эту функцию вместо вызова [`pow(){:tact}`](#pow), когда вам нужно получить только степени $2$.

:::

:::note

  Список функций, которые работают только во время компиляции: [API Comptime](/ref/core-comptime).

:::

## checkSignature

```tact
fun checkSignature(hash: Int, signature: Slice, public_key: Int): Bool;
```

Проверяет [Ed25519][ed] `signature` $256$-битного беззнакового [`Int{:tact}`][int] `hash` с помощью `public_key`, представленного также $256$-битным беззнаковым [`Int{:tact}`][int]. Подпись должна содержать не менее $512$ бит данных, но используются только первые $512$ бит.

Возвращает `true{:tact}`, если подпись действительна, и `false{:tact}` в противном случае.

Пример использования:

```tact {19-24}
message ExtMsg {
    signature: Slice;
    data: Cell;
}

contract Showcase {
    // Постоянные состояния переменных
    pub: Int as uint256; // открытый ключ как 256-битное беззнаковое целое число

    // Функция-конструктор init(), где инициализируются все переменные
    init(pub: Int) {
        self.pub = pub; // сохранение открытого ключа при инициализации контракта
    }

    // Внешний приемник сообщений, который принимает сообщение ExtMsg
    external(msg: ExtMsg) {
        let hash: Int = beginCell().storeRef(msg.data).endCell().hash();
        let check: Bool = checkSignature(hash, msg.signature, self.pub);
        //                               ----  -------------  --------
        //                               ↑     ↑              ↑
        //                               |     |              public_key, хранится в нашем контракте
        //                               |     подпись, полученная из полученного сообщения
        //                               хэш, рассчитанный с использованием данных из полученного сообщения
        // ... логика последующих действий ...
    }
}
```

## checkDataSignature

```tact
fun checkDataSignature(data: Slice, signature: Slice, public_key: Int): Bool;
```

Проверяет [Ed25519][ed] `signature` для `data` с помощью `public_key`, аналогично [`checkSignature(){:tact}`](#checksignature). Если длина бит `data` не делится на $8$, эта функция выдает ошибку с [кодом выхода 9](/book/exit-codes#9): `Переполнение ячейки`. Сама проверка выполняется косвенно: по [SHA-256][sha-2] хэшу `data`.

Возвращает `true{:tact}`, если подпись действительна, и `false{:tact}` в противном случае.

Пример использования:

```tact
let data: Slice = some_data;
let signature: Slice = some_signature;
let publicKey: Int = 42;

let check: Bool = checkSignature(data, signature, publicKey);
```

## sha256

```tact
fun sha256(data: Slice): Int;
fun sha256(data: String): Int;
```

Вычисляет и возвращает хэш [SHA-256][sha-2] как $256$-битный беззнаковый [`Int{:tact}`][int] из переданного [`Slice{:tact}`][slice] или [`String{:tact}`][p] `data`.

В случае, если `data` представляет собой [`String{:tact}`][p], оно должно содержать количество битов, кратное $8$, а в случае, если это [`Slice{:tact}`][slice], оно также не должно содержать ссылок (т.е. всего до $1023$ бит данных). Эта функция пытается разрешить постоянные строковые значения во время [компиляции] (/ref/core-comptime), когда это возможно.

:::caution

  Если значение [`String{:tact}`][p] не может быть разрешено во время [компиляции](/ref/core-comptime), то хэш вычисляется во время выполнения самим [TVM][tvm]. Обратите внимание, что хэширование строк с более чем $128$ байтами [TVM][tvm] может вызвать коллизии, если их первые $128$ байтов одинаковы.

  Поэтому, по возможности, предпочитайте использовать статически известные строки. В случае сомнений используйте строки длиной до $128$ байт.

:::

Примеры использования:

```tact
sha256(beginCell().asSlice());
sha256("Hello, world!"); // будет разрешено во время компиляции
sha256(someVariableElsewhere); // попытается разрешить во время компиляции,
                               // и вернуться к оценке во время выполнения
```

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[нарезать]: /book/cells#slices
[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[ред]: https://en.wikipedia.org/wiki/EdDSA#Ed25519
[sha-2]: https://en.wikipedia.org/wiki/SHA-2#Hash_standard
