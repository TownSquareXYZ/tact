---
title: "OTP-001: Поддерживаемые интерфейсы"
description: В этом предложении рекомендуется проанализировать смарт-контракты и выяснить, какие интерфейсы они поддерживают
sidebar:
  order: 1
---

В этом предложении рекомендуется проанализировать смарт-контракты и выяснить, какие интерфейсы они поддерживают.

## Мотивация

Сейчас невозможно угадать, что пользователь хочет сделать с контрактом, или не понять, о чем транзакция, потому что нет четкого способа узнать, о чем идет речь в контракте. В большинстве случаев людям нужно помнить или догадываться, о чем идет речь.

## Руководство

Когда человек пытается подписать транзакцию, ему нужно четко понимать, что он делает: чеканка, передача токенов, стейкинг, голосование DAO. Хотя кошельки Ethereum поддерживают подписание произвольных структур, все еще неясно, что вы подписываете и каковы последствия этого. Точно так же обозреватели не могут показать, что происходит, в удобной форме.

Начало работы с конкретным контрактом состоит в проведении исследования - выяснения того, что в контракте говорится о самом себе. Когда приложение знает, что именно делает этот контракт, оно может создать хороший интерфейс пользователя, показать историю транзакций и проверить, что человек пытается подписать.

Это предложение описывает способ сообщить, какие интерфейсы поддерживает контракт.

Интерфейсы определяются в свободной форме спецификации. В отличие от большинства других подходов, это предложение определяет интерфейс не только как технический интерфейс контракта (методы получения, внутренние сообщения и т. д.), но и как описание его поведения. Добавление хэша к представлению технического интерфейса контракта может привести к конфликтам между различными стандартами, и из-за этого предложение определяет интерфейсы нечетко. Кроме того, это позволяет сделать интерфейс более гибким, например, токен, который не может быть передан, может быть просто контрактом, который должен получить метод `can_transfer`, который возвращает `false`, и это будет означать, что этот токен вообще не поддерживает переводы без необходимости реализации этого метода.

Идентификаторы интерфейсов — это хеши обратных доменных имен (как пакеты в Java), это позволяет избежать конфликтов имен между разными командами, если они хотят создать что-то только для себя.

## Спецификация

Для поддержки контракта интроспекции ДОЛЖЕН быть реализован метод GET supports_interface:

`(int...) supported_interfaces()`
Который возвращает список поддерживаемых кодов интерфейсов. Первое значение ДОЛЖНО быть `hash("org.ton.introspection.v0")` = `123515602279859691144772641439386770278`.
Если первое значение неверно, приложение ДОЛЖНО прекратить попытки исследовать контракт.
Пример

```func
_ supported_interfaces() method_id {
    return (123515602279859691144772641439386770278);
}
```

Хеш интерфейса определяется как усеченный до 128 бит SHA256.

## Недостатки

Это предложение не гарантирует, что контракт будет вести себя правильно по отношению к интерфейсу, а также не предоставляет гарантированного способа избежать конфликтов имен между различными интерфейсами. Это не является целью данного предложения.

Это предложение не привязано к определенному техническому интерфейсу. Это может привести к появлению нескольких интерфейсов, которые будут выполнять одно и то же, но с разными идентификаторами. Это не является целью данного предложения, так как централизованный реестр будет очень полезен для существующих интерфейсов, а пользовательский реестр будет использоваться в основном внутри организации.

## Обоснование и альтернативы

- Почему 128 бит? Мы рассматриваем глобальное пространство имен, которое нам нужно сохранить без конфликтов, мы не можем использовать что-либо намного меньшего размера, поскольку вероятность конфликтов была бы намного выше. Мы рассматриваем энтропию, подобную UUID, которая составляет ровно 128 бит и проверена временем. Более 128 бит слишком избыточно.
- Почему свободная форма? Как упоминалось ранее, проще просто определить какой-то идентификатор, чтобы начать работу пораньше, а затем в конечном итоге построить стандарт. Также интерфейсы (например, ERC20) обычно не просто технический интерфейс, но и ряд правил о том, как с ним работать.
- Почему бы не выяснить, что поддерживает контракт, путем декомпиляции? Явное всегда лучше неявного в сценариях открытого мира. Мы не можем полагаться на наши возможности "дизассемблирования" для выполнения интроспекции, даже небольшие ошибки могут оказаться фатальными.
- Почему бы не использовать хэширование представления? Прямо сейчас нет компиляторов, которые это поддерживают, но это предложение рассчитано на будущее. Если кто-то захочет создать что-то более автоматизированное, он может легко создать свои собственные хэши по своим правилам, сохраняя все как есть для внешних наблюдателей.

## Предшествующий уровень техники

[Обнаружение интерфейса Ethereum](https://eips.ethereum.org/EIPS/eip-165)
