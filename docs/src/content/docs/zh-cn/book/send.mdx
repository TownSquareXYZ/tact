---
title: Sending messages
---

TON blockchain is a message-based one to communicate with other contracts you need to send messages.

Messages in Tact are commonly composed using a built-in [Struct](/book/structs-and-messages#structs) `SendParameters{:tact}`, which consists of:

| Field    | Type                   | Description                                                                                                                                                             |
| :------- | :--------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `bounce` | [`Bool{:tact}`][p]     | `bounce` - if set to `true` (default) then the message will be bounced back to the sender if the receiver contract doesn't exist or wasn't able to process the message. |
| `to`     | [`Address{:tact}`][p]  | Receiver internal [`Address{:tact}`][p] in TON blockchain.                                                                                                              |
| `value`  | [`Int{:tact}`][int]    | `value` in TON - the amount of TON you want to send with the message. This value is used to cover gas fees on the receiver side.                                        |
| `mode`   | [`Int{:tact}`][int]    | An 8-bit value that configures how to send a message, defaults to $0$. See: [Message `mode`](/book/message-mode).                                                       |
| `body`   | [`Cell?{:tact}`][cell] | [Optional][opt] message body as a [`Cell{:tact}`][cell]                                                                                                                 |
| `code`   | [`Cell?{:tact}`][cell] | [Optional][opt] initial code of the contract (the compiled bytecode)                                                                                                    |
| `data`   | [`Cell?{:tact}`][cell] | [Optional][opt] initial data of the contract (arguments of [`init(){:tact}` function](/book/contracts#init-function) of the contract)                                   |

Fields `code` and `data` are what's called an [init package](/book/expressions#initof), which is used in deployments of new contracts.

## Send simple reply

The simplest message is a reply to the incoming message returning all excess value of a message:

```tact
self.reply("Hello, World!".asComment()); // asComment converts string to a Cell with a comment
```

## Send message

If you need more advanced logic you can use the `send` function directly.

In fact, the previous example with [`.reply(){:tact}`](#send-simple-reply) can be made using the following call to `send(){:tact}` function:

```tact
let to: Address = ...;
let value: Int = ton("1");
send(SendParameters{
    to: to,
    value: value, 
    mode: SendIgnoreErrors, 
    bounce: true, 
    body: "Hello, World!".asComment()
});
```

This example sends a message to the `to` address with a `value` of 1 TON and the `body` of a comment with a string "Hello, World!".

```tact
`mode` - an 8-bit flag that configures how to send a message
```

`SendIgnoreErrors` means that even when an error occurs during message sending next messages would be sent anyway. **No error during the sending phase would revert a transaction.**

## Send typed message

To send a binary typed message you can use the following code:

```tact
let init: StateInit = initOf SecondContract(arg1, arg2);
let address: Address = contractAddress(init);
let value: Int = ton("1");
send(SendParameters{
    to: address,
    value: value, 
    mode: SendIgnoreErrors, 
    bounce: true, 
    code: init.code,
    data: init.data,
    body: "Hello, World!".asComment()
});
```

## Deploy contract

To deploy a contract you need to calculate its address and init package, then send it with an initial message.

```tact
let to: Address = ...;
let value: Int = ton("1");
send(SendParameters{
    to: to,
    value: value, 
    mode: SendIgnoreErrors, 
    bounce: true, 
    body: SomeMessage{arg1: 123, arg2: 1234}.toCell()
});
```

## Outbound message processing

Each transaction on TON Blockchain consists of [multiple phases][phases]. Outbound messages are evaluated in [compute phase][compute], but are **not** sent in that phase. Instead, they're queued in order of appearance for the [action phase][phases], where all actions listed in [compute phase][compute], like outbound messages or [reserve requests](/ref/core-advanced#nativereserve), are executed.

As all the values are computed in [compute phase][compute], all the fees computed by the end of it, and exceptions do not revert the transaction during [action phase][phases], outbound message sends can fail without bounce due to unsufficient [action fees](https://docs.ton.org/develop/howto/fees-low-level#action-fee) or [forward fees][fwdfee].

Consider the following example:

```tact
// This contract initially has 0 nanoToncoins on the balance
contract FailureIsNothingButAnotherStep {
    // And all the funds it gets are obtained from inbound internal messages
    receive() {
        // 1st outbound message evaluated and queued (but not sent yet)
        send(SendParameters{
            to: sender(),
            value: ton("0.042"), // plus forward fee due to SendPayGasSeparately
            mode: SendIgnoreErrors | SendPayGasSeparately,
        });

        // 2nd outbound message evaluated and queued (but not sent yet, and never will be!)
        send(SendParameters{
            to: sender(),
            value: 0,
            mode: SendRemainingValue | SendIgnoreErrors,
        });
    }
}
```

There, the second message won't actually be sent:

- After finishing the [compute phase][compute], the remaining value $\mathrm{R}$ of the contract is computed.

- During the outbound message processing and assuming that there was enough value provided in the inbound message, the first message leaves $\mathrm{R} - (0.042 + \mathrm{forward\_fees})$ [nanoToncoins](/book/integers#nanotoncoin) on the balance.

- When the second message is processed, contract tries to send $\mathrm{R}$ [nanoToncoins](/book/integers#nanotoncoin), but fails to do so because there is already a smaller amount left.

:::note

  Read more about all message sending functions in the Reference:

- [`send(){:tact}`](/ref/core-common#send)
- [`emit(){:tact}`](/ref/core-common#emit)
- [`self.notify(){:tact}`](/ref/core-base#self-notify)
- [`self.reply(){:tact}`](/ref/core-base#self-reply)
- [`self.forward(){:tact}`](/ref/core-base#self-forward)
- [`nativeSendMessage(){:tact}`](/ref/core-advanced#nativesendmessage)

:::

[p]: /book/types#primitive-types
[int]: /book/integers
[cell]: /book/cells#cells
[opt]: /book/optionals
[phases]: https://docs.ton.org/learn/tvm-instructions/tvm-overview#transactions-and-phases
[compute]: https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase
[nano]: /book/integers#nanotoncoin
[fwdfee]: https://docs.ton.org/develop/howto/fees-low-level#forward-fees
