---
title: Type system overview
---

Every variable, item, and value in Tact programs has a type. They can be:

- One of the [primitive types](#primitive-types)
- or [composite types](#composite-types)

Also, many of those types [can be made nullable](/book/defining-types#optionals).

## Primitive types

Tact supports a number of primitive data types that are tailored for smart contract use:

- Int — all numbers in Tact are 257-bit signed integers, but [smaller representations](/book/integers#serialization) can be used to reduce storage costs.
- Bool — classical boolean with `true` and `false` values.
- Address — standard [smart contract address](https://docs.ton.org/learn/overviews/addresses#address-of-smart-contract) in TON Blockchain.
- [`Cell{:tact}`](/book/cells#cells), [`Builder{:tact}`](/book/cells#builders), [`Slice{:tact}`](/book/cells#slices) — low-level primitives of [TVM][tvm].
- `String{:tact}` — immutable text strings.
- StringBuilder — helper type that allows you to concatenate strings in a gas-efficient way.

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview

### Booleans {#booleans}

The primitive type `Bool{:tact}` is the classical boolean type, which can hold only the two values: `true{:tact}` and `false{:tact}`. It's convenient for boolean and logical operations, as well as for storing flags.

There are no implicit type conversions in Tact, so addition ([`+{:tact}`](/book/operators#binary-add)) of two boolean values isn't possible. Hovewer, many comparison [operators](/book/operators) are available, such as:

- `&&{:tact}` for [logical AND](/book/operators#binary-logical-and),
- `||{:tact}` for [logical OR](/book/operators#binary-logical-or),
- `!{:tact}` for [logical inversion](/book/operators#unary-inverse),
- `=={:tact}` and `!={:tact}` for checking [equality](/book/operators#binary-equality),
- and `!!{:tact}` for [non-null assertion](/book/optionals).

Persisting bools to state is very space-efficient, as they only take 1-bit. Storing 1000 bools in state [costs](https://ton.org/docs/develop/smart-contracts/fees#how-to-calculate-fees) about $0.00072$ TON per year.

## Composite types

Using individual means of storage often becomes cumbersome, so there are ways to combine multiple [primitive types](#primitive-types) together to create composite types:

- [Maps](#maps) — associations of keys with values.
- Composite types, such as [Structs and Messages](#structs-and-messages)
- [Optionals](#optionals) — `null{:tact}` values for variables or fields of [Structs and Messages](#structs-and-messages).

In addition to the composite types above, Tact provides a special type constructor [`bounced<T>{:tact}`](/book/bounced), which can only be specified in [bounced message receivers](/book/bounced).

Note, while [contracts](#contracts) and [traits](#traits) are also considered a part of the Tacts type system, one can't pass them around like [Structs and Messages](#structs-and-messages). Instead, it's possible to obtain the initial state of the given contract by using the [`initOf{:tact}`](/book/expressions#initof) expression.

### Maps

The type `map<k, v>{:tact}` is used as a way to associate data with corresponding keys.

contract HelloWorld {
    counters: map<Int, Int>;
}

```tact
let mapExample: map<Int, Int> = emptyMap(); // empty map with Int keys and values
```

Learn more about them on a dedicated page: [Maps][maps].

[[Maps](#maps)]: /book/maps

### Structs and Messages

Possible key types:

[Struct](/book/defining-types#structs) example:

```tact
struct Point {
    x: Int;
    y: Int;
}
```

[Message](/book/defining-types#messages) example:

```tact
// Custom numeric id of the Message
message(0x11111111) SetValue {
    key: Int;
    value: Int?; // Optional
    coins: Int as coins; // Serialization into TL-B types
}
```

Learn more about them on a dedicated page: [Structs and Messages][s-n-m].

[s-n-m]: Address
[structs]: [Struct](/book/defining-types#structs)
[messages]: [Message](/book/defining-types#messages)

### Optionals

All [primitive types](#primitive-types), as well as [Structs and Messages](#structs-and-messages) could be nullable and hold a special `null{:tact}` value.

Example of an [optional][optionals]:

```tact
let opt: Int? = null; // Int or null, with explicitly assigned null
```

Learn more about them on a dedicated page about [defining composite types](/book/defining-types).

[optionals]: /book/optionals

### Contracts

Contracts are the main entry of a smart contract on the TON blockchain. It holds all functions, getters, and receivers of a TON contract.

Example of a [contract](/book/contracts):

```tact
contract HelloWorld {
    counter: Int;

    init() {
        self.counter = 0;
    }

    receive("increment") {
        self.counter = self.counter + 1;
    }

    get fun counter(): Int {
        return self.counter;
    }
}
```

or [Contracts](#contracts) and [Traits](#traits)

### Traits

Tact doesn't support classical class inheritance, but instead introduces the concept of **traits**. They have the same structure as [contracts](#contracts), but can't [initialize persistent state variables](/book/contracts#init-function).

A trait can also let the contract inheriting it to override the behavior of its [functions](/book/functions#virtual-and-abstract-functions) and the value of its [constants](/book/constants#virtual-and-abstract-constants).

Example of a trait [`Ownable{:tact}`](/ref/stdlib-ownable#ownable) from [`@stdlib/ownable`](/ref/stdlib-ownable):

```tact
trait Ownable {
    owner: Address;

    fun requireOwner() {
        nativeThrowUnless(132, context().sender == self.owner);
    }

    get fun owner(): Address {
        return self.owner;
    }
}
```

And the contract that uses trait:

```tact
contract Treasure with Ownable {
  owner: Address; // Field from trait MUST be defined in contract itself

  // Here we init the way we need, trait can't specify how you must init owner field
  init(owner: Address) {
    self.owner = owner;
  }
}
```
